/*
 * generated by Xtext 2.9.0
 */
package org.hopper.language.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class PortugolGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cHeaderAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cHeaderHeaderBlockParserRuleCall_0_0 = (RuleCall)cHeaderAssignment_0.eContents().get(0);
		private final Assignment cGlobalDeclarationsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cGlobalDeclarationsDeclarationsBlockParserRuleCall_1_0 = (RuleCall)cGlobalDeclarationsAssignment_1.eContents().get(0);
		private final Assignment cSubprogramsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSubprogramsSubprogramsParserRuleCall_2_0 = (RuleCall)cSubprogramsAssignment_2.eContents().get(0);
		private final Assignment cCommandsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCommandsBlockCommandParserRuleCall_3_0 = (RuleCall)cCommandsAssignment_3.eContents().get(0);
		
		//Model:
		//	header=HeaderBlock
		//	globalDeclarations=DeclarationsBlock
		//	subprograms=Subprograms?
		//	commands=BlockCommand;
		@Override public ParserRule getRule() { return rule; }
		
		//header=HeaderBlock globalDeclarations=DeclarationsBlock subprograms=Subprograms? commands=BlockCommand
		public Group getGroup() { return cGroup; }
		
		//header=HeaderBlock
		public Assignment getHeaderAssignment_0() { return cHeaderAssignment_0; }
		
		//HeaderBlock
		public RuleCall getHeaderHeaderBlockParserRuleCall_0_0() { return cHeaderHeaderBlockParserRuleCall_0_0; }
		
		//globalDeclarations=DeclarationsBlock
		public Assignment getGlobalDeclarationsAssignment_1() { return cGlobalDeclarationsAssignment_1; }
		
		//DeclarationsBlock
		public RuleCall getGlobalDeclarationsDeclarationsBlockParserRuleCall_1_0() { return cGlobalDeclarationsDeclarationsBlockParserRuleCall_1_0; }
		
		//subprograms=Subprograms?
		public Assignment getSubprogramsAssignment_2() { return cSubprogramsAssignment_2; }
		
		//Subprograms
		public RuleCall getSubprogramsSubprogramsParserRuleCall_2_0() { return cSubprogramsSubprogramsParserRuleCall_2_0; }
		
		//commands=BlockCommand
		public Assignment getCommandsAssignment_3() { return cCommandsAssignment_3; }
		
		//BlockCommand
		public RuleCall getCommandsBlockCommandParserRuleCall_3_0() { return cCommandsBlockCommandParserRuleCall_3_0; }
	}
	public class HeaderBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.HeaderBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAlgoritmoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final RuleCall cEND_COMMANDTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//HeaderBlock:
		//	'algoritmo' name=STRING END_COMMAND;
		@Override public ParserRule getRule() { return rule; }
		
		//'algoritmo' name=STRING END_COMMAND
		public Group getGroup() { return cGroup; }
		
		//'algoritmo'
		public Keyword getAlgoritmoKeyword_0() { return cAlgoritmoKeyword_0; }
		
		//name=STRING
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0() { return cNameSTRINGTerminalRuleCall_1_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_2() { return cEND_COMMANDTerminalRuleCall_2; }
	}
	public class DeclarationsBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.DeclarationsBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVarKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cEND_COMMANDTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cVarsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cVarsVariableParserRuleCall_2_0_0 = (RuleCall)cVarsAssignment_2_0.eContents().get(0);
		private final RuleCall cEND_COMMANDTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		
		//DeclarationsBlock:
		//	'var' END_COMMAND (vars+=Variable END_COMMAND)+;
		@Override public ParserRule getRule() { return rule; }
		
		//'var' END_COMMAND (vars+=Variable END_COMMAND)+
		public Group getGroup() { return cGroup; }
		
		//'var'
		public Keyword getVarKeyword_0() { return cVarKeyword_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_1() { return cEND_COMMANDTerminalRuleCall_1; }
		
		//(vars+=Variable END_COMMAND)+
		public Group getGroup_2() { return cGroup_2; }
		
		//vars+=Variable
		public Assignment getVarsAssignment_2_0() { return cVarsAssignment_2_0; }
		
		//Variable
		public RuleCall getVarsVariableParserRuleCall_2_0_0() { return cVarsVariableParserRuleCall_2_0_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_2_1() { return cEND_COMMANDTerminalRuleCall_2_1; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarDeclarationAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarDeclarationVarDeclarationParserRuleCall_0_0 = (RuleCall)cVarDeclarationAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeVarTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//Variable:
		//	varDeclaration=VarDeclaration ':' type=VarType;
		@Override public ParserRule getRule() { return rule; }
		
		//varDeclaration=VarDeclaration ':' type=VarType
		public Group getGroup() { return cGroup; }
		
		//varDeclaration=VarDeclaration
		public Assignment getVarDeclarationAssignment_0() { return cVarDeclarationAssignment_0; }
		
		//VarDeclaration
		public RuleCall getVarDeclarationVarDeclarationParserRuleCall_0_0() { return cVarDeclarationVarDeclarationParserRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=VarType
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//VarType
		public RuleCall getTypeVarTypeParserRuleCall_2_0() { return cTypeVarTypeParserRuleCall_2_0; }
	}
	public class VarDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.VarDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarsVarNameParserRuleCall_0_0 = (RuleCall)cVarsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cVarsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cVarsVarNameParserRuleCall_1_1_0 = (RuleCall)cVarsAssignment_1_1.eContents().get(0);
		
		//VarDeclaration:
		//	vars+=VarName (',' vars+=VarName)*;
		@Override public ParserRule getRule() { return rule; }
		
		//vars+=VarName (',' vars+=VarName)*
		public Group getGroup() { return cGroup; }
		
		//vars+=VarName
		public Assignment getVarsAssignment_0() { return cVarsAssignment_0; }
		
		//VarName
		public RuleCall getVarsVarNameParserRuleCall_0_0() { return cVarsVarNameParserRuleCall_0_0; }
		
		//(',' vars+=VarName)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//vars+=VarName
		public Assignment getVarsAssignment_1_1() { return cVarsAssignment_1_1; }
		
		//VarName
		public RuleCall getVarsVarNameParserRuleCall_1_1_0() { return cVarsVarNameParserRuleCall_1_1_0; }
	}
	public class DeclaredVarElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.DeclaredVar");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cVarsVarNameCrossReference_0_0 = (CrossReference)cVarsAssignment_0.eContents().get(0);
		private final RuleCall cVarsVarNameIDTerminalRuleCall_0_0_1 = (RuleCall)cVarsVarNameCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cVarsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final CrossReference cVarsVarNameCrossReference_1_1_0 = (CrossReference)cVarsAssignment_1_1.eContents().get(0);
		private final RuleCall cVarsVarNameIDTerminalRuleCall_1_1_0_1 = (RuleCall)cVarsVarNameCrossReference_1_1_0.eContents().get(1);
		
		//DeclaredVar:
		//	vars+=[VarName] (',' vars+=[VarName])*;
		@Override public ParserRule getRule() { return rule; }
		
		//vars+=[VarName] (',' vars+=[VarName])*
		public Group getGroup() { return cGroup; }
		
		//vars+=[VarName]
		public Assignment getVarsAssignment_0() { return cVarsAssignment_0; }
		
		//[VarName]
		public CrossReference getVarsVarNameCrossReference_0_0() { return cVarsVarNameCrossReference_0_0; }
		
		//ID
		public RuleCall getVarsVarNameIDTerminalRuleCall_0_0_1() { return cVarsVarNameIDTerminalRuleCall_0_0_1; }
		
		//(',' vars+=[VarName])*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//vars+=[VarName]
		public Assignment getVarsAssignment_1_1() { return cVarsAssignment_1_1; }
		
		//[VarName]
		public CrossReference getVarsVarNameCrossReference_1_1_0() { return cVarsVarNameCrossReference_1_1_0; }
		
		//ID
		public RuleCall getVarsVarNameIDTerminalRuleCall_1_1_0_1() { return cVarsVarNameIDTerminalRuleCall_1_1_0_1; }
	}
	public class VarNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.VarName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//VarName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class VarTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.VarType");
		private final Assignment cTypeNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cTypeNameAlternatives_0 = (Alternatives)cTypeNameAssignment.eContents().get(0);
		private final Keyword cTypeNameRealKeyword_0_0 = (Keyword)cTypeNameAlternatives_0.eContents().get(0);
		private final Keyword cTypeNameInteiroKeyword_0_1 = (Keyword)cTypeNameAlternatives_0.eContents().get(1);
		private final Keyword cTypeNameCaractereKeyword_0_2 = (Keyword)cTypeNameAlternatives_0.eContents().get(2);
		
		//VarType:
		//	typeName=('real' | 'inteiro' | 'caractere');
		@Override public ParserRule getRule() { return rule; }
		
		//typeName=('real' | 'inteiro' | 'caractere')
		public Assignment getTypeNameAssignment() { return cTypeNameAssignment; }
		
		//('real' | 'inteiro' | 'caractere')
		public Alternatives getTypeNameAlternatives_0() { return cTypeNameAlternatives_0; }
		
		//'real'
		public Keyword getTypeNameRealKeyword_0_0() { return cTypeNameRealKeyword_0_0; }
		
		//'inteiro'
		public Keyword getTypeNameInteiroKeyword_0_1() { return cTypeNameInteiroKeyword_0_1; }
		
		//'caractere'
		public Keyword getTypeNameCaractereKeyword_0_2() { return cTypeNameCaractereKeyword_0_2; }
	}
	public class SubprogramsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Subprograms");
		private final Assignment cBlockSubProgramsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cBlockSubProgramsBlockSubProgramsParserRuleCall_0 = (RuleCall)cBlockSubProgramsAssignment.eContents().get(0);
		
		//Subprograms:
		//	blockSubPrograms+=BlockSubPrograms+;
		@Override public ParserRule getRule() { return rule; }
		
		//blockSubPrograms+=BlockSubPrograms+
		public Assignment getBlockSubProgramsAssignment() { return cBlockSubProgramsAssignment; }
		
		//BlockSubPrograms
		public RuleCall getBlockSubProgramsBlockSubProgramsParserRuleCall_0() { return cBlockSubProgramsBlockSubProgramsParserRuleCall_0; }
	}
	public class BlockSubProgramsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.BlockSubPrograms");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBlockFunctionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBlockProcedureParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//BlockSubPrograms:
		//	BlockFunction | BlockProcedure;
		@Override public ParserRule getRule() { return rule; }
		
		//BlockFunction | BlockProcedure
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BlockFunction
		public RuleCall getBlockFunctionParserRuleCall_0() { return cBlockFunctionParserRuleCall_0; }
		
		//BlockProcedure
		public RuleCall getBlockProcedureParserRuleCall_1() { return cBlockProcedureParserRuleCall_1; }
	}
	public class FunctionNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.FunctionName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//FunctionName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class ProcedureNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.ProcedureName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//ProcedureName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class BlockFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.BlockFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFuncaoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFunctionNameFunctionNameParserRuleCall_1_0 = (RuleCall)cFunctionNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cParamListAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParamListVariableParserRuleCall_3_0 = (RuleCall)cParamListAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cColonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cReturnTypeAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cReturnTypeVarTypeParserRuleCall_6_0 = (RuleCall)cReturnTypeAssignment_6.eContents().get(0);
		private final RuleCall cEND_COMMANDTerminalRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		private final Assignment cDeclarationsAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cDeclarationsDeclarationsBlockParserRuleCall_8_0 = (RuleCall)cDeclarationsAssignment_8.eContents().get(0);
		private final Keyword cInicioKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final RuleCall cEND_COMMANDTerminalRuleCall_10 = (RuleCall)cGroup.eContents().get(10);
		private final Assignment cCommandsAssignment_11 = (Assignment)cGroup.eContents().get(11);
		private final RuleCall cCommandsAbstractCommandParserRuleCall_11_0 = (RuleCall)cCommandsAssignment_11.eContents().get(0);
		private final Keyword cFimfuncaoKeyword_12 = (Keyword)cGroup.eContents().get(12);
		private final RuleCall cEND_COMMANDTerminalRuleCall_13 = (RuleCall)cGroup.eContents().get(13);
		
		//BlockFunction:
		//	'funcao' functionName=FunctionName '(' paramList=Variable ')' ':' returnType=VarType END_COMMAND
		//	declarations=DeclarationsBlock?
		//	'inicio' END_COMMAND
		//	commands+=AbstractCommand+
		//	'fimfuncao' END_COMMAND;
		@Override public ParserRule getRule() { return rule; }
		
		//'funcao' functionName=FunctionName '(' paramList=Variable ')' ':' returnType=VarType END_COMMAND
		//declarations=DeclarationsBlock? 'inicio' END_COMMAND commands+=AbstractCommand+ 'fimfuncao' END_COMMAND
		public Group getGroup() { return cGroup; }
		
		//'funcao'
		public Keyword getFuncaoKeyword_0() { return cFuncaoKeyword_0; }
		
		//functionName=FunctionName
		public Assignment getFunctionNameAssignment_1() { return cFunctionNameAssignment_1; }
		
		//FunctionName
		public RuleCall getFunctionNameFunctionNameParserRuleCall_1_0() { return cFunctionNameFunctionNameParserRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//paramList=Variable
		public Assignment getParamListAssignment_3() { return cParamListAssignment_3; }
		
		//Variable
		public RuleCall getParamListVariableParserRuleCall_3_0() { return cParamListVariableParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//':'
		public Keyword getColonKeyword_5() { return cColonKeyword_5; }
		
		//returnType=VarType
		public Assignment getReturnTypeAssignment_6() { return cReturnTypeAssignment_6; }
		
		//VarType
		public RuleCall getReturnTypeVarTypeParserRuleCall_6_0() { return cReturnTypeVarTypeParserRuleCall_6_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_7() { return cEND_COMMANDTerminalRuleCall_7; }
		
		//declarations=DeclarationsBlock?
		public Assignment getDeclarationsAssignment_8() { return cDeclarationsAssignment_8; }
		
		//DeclarationsBlock
		public RuleCall getDeclarationsDeclarationsBlockParserRuleCall_8_0() { return cDeclarationsDeclarationsBlockParserRuleCall_8_0; }
		
		//'inicio'
		public Keyword getInicioKeyword_9() { return cInicioKeyword_9; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_10() { return cEND_COMMANDTerminalRuleCall_10; }
		
		//commands+=AbstractCommand+
		public Assignment getCommandsAssignment_11() { return cCommandsAssignment_11; }
		
		//AbstractCommand
		public RuleCall getCommandsAbstractCommandParserRuleCall_11_0() { return cCommandsAbstractCommandParserRuleCall_11_0; }
		
		//'fimfuncao'
		public Keyword getFimfuncaoKeyword_12() { return cFimfuncaoKeyword_12; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_13() { return cEND_COMMANDTerminalRuleCall_13; }
	}
	public class BlockProcedureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.BlockProcedure");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cProcedimentoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cProcedureAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cProcedureProcedureNameParserRuleCall_1_0 = (RuleCall)cProcedureAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cParamListAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParamListVariableParserRuleCall_3_0 = (RuleCall)cParamListAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final RuleCall cEND_COMMANDTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final Assignment cDeclarationsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cDeclarationsDeclarationsBlockParserRuleCall_6_0 = (RuleCall)cDeclarationsAssignment_6.eContents().get(0);
		private final Keyword cInicioKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final RuleCall cEND_COMMANDTerminalRuleCall_8 = (RuleCall)cGroup.eContents().get(8);
		private final Assignment cCommandsAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cCommandsAbstractCommandParserRuleCall_9_0 = (RuleCall)cCommandsAssignment_9.eContents().get(0);
		private final Keyword cFimprocedimentoKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final RuleCall cEND_COMMANDTerminalRuleCall_11 = (RuleCall)cGroup.eContents().get(11);
		
		//BlockProcedure:
		//	'procedimento' procedure=ProcedureName '(' paramList=Variable ')' END_COMMAND
		//	declarations=DeclarationsBlock?
		//	'inicio' END_COMMAND
		//	commands+=AbstractCommand+
		//	'fimprocedimento' END_COMMAND;
		@Override public ParserRule getRule() { return rule; }
		
		//'procedimento' procedure=ProcedureName '(' paramList=Variable ')' END_COMMAND declarations=DeclarationsBlock? 'inicio'
		//END_COMMAND commands+=AbstractCommand+ 'fimprocedimento' END_COMMAND
		public Group getGroup() { return cGroup; }
		
		//'procedimento'
		public Keyword getProcedimentoKeyword_0() { return cProcedimentoKeyword_0; }
		
		//procedure=ProcedureName
		public Assignment getProcedureAssignment_1() { return cProcedureAssignment_1; }
		
		//ProcedureName
		public RuleCall getProcedureProcedureNameParserRuleCall_1_0() { return cProcedureProcedureNameParserRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//paramList=Variable
		public Assignment getParamListAssignment_3() { return cParamListAssignment_3; }
		
		//Variable
		public RuleCall getParamListVariableParserRuleCall_3_0() { return cParamListVariableParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_5() { return cEND_COMMANDTerminalRuleCall_5; }
		
		//declarations=DeclarationsBlock?
		public Assignment getDeclarationsAssignment_6() { return cDeclarationsAssignment_6; }
		
		//DeclarationsBlock
		public RuleCall getDeclarationsDeclarationsBlockParserRuleCall_6_0() { return cDeclarationsDeclarationsBlockParserRuleCall_6_0; }
		
		//'inicio'
		public Keyword getInicioKeyword_7() { return cInicioKeyword_7; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_8() { return cEND_COMMANDTerminalRuleCall_8; }
		
		//commands+=AbstractCommand+
		public Assignment getCommandsAssignment_9() { return cCommandsAssignment_9; }
		
		//AbstractCommand
		public RuleCall getCommandsAbstractCommandParserRuleCall_9_0() { return cCommandsAbstractCommandParserRuleCall_9_0; }
		
		//'fimprocedimento'
		public Keyword getFimprocedimentoKeyword_10() { return cFimprocedimentoKeyword_10; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_11() { return cEND_COMMANDTerminalRuleCall_11; }
	}
	public class BlockCommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.BlockCommand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInicioKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cEND_COMMANDTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cCommandsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCommandsAbstractCommandParserRuleCall_2_0 = (RuleCall)cCommandsAssignment_2.eContents().get(0);
		private final Keyword cFimalgoritmoKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final RuleCall cEND_COMMANDTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//BlockCommand:
		//	'inicio' END_COMMAND
		//	commands+=AbstractCommand+
		//	'fimalgoritmo' END_COMMAND;
		@Override public ParserRule getRule() { return rule; }
		
		//'inicio' END_COMMAND commands+=AbstractCommand+ 'fimalgoritmo' END_COMMAND
		public Group getGroup() { return cGroup; }
		
		//'inicio'
		public Keyword getInicioKeyword_0() { return cInicioKeyword_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_1() { return cEND_COMMANDTerminalRuleCall_1; }
		
		//commands+=AbstractCommand+
		public Assignment getCommandsAssignment_2() { return cCommandsAssignment_2; }
		
		//AbstractCommand
		public RuleCall getCommandsAbstractCommandParserRuleCall_2_0() { return cCommandsAbstractCommandParserRuleCall_2_0; }
		
		//'fimalgoritmo'
		public Keyword getFimalgoritmoKeyword_3() { return cFimalgoritmoKeyword_3; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_4() { return cEND_COMMANDTerminalRuleCall_4; }
	}
	public class AbstractCommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.AbstractCommand");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cReadCommandParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cWriteCommandParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AbstractCommand:
		//	ReadCommand
		//	| WriteCommand;
		@Override public ParserRule getRule() { return rule; }
		
		//ReadCommand | WriteCommand
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ReadCommand
		public RuleCall getReadCommandParserRuleCall_0() { return cReadCommandParserRuleCall_0; }
		
		//WriteCommand
		public RuleCall getWriteCommandParserRuleCall_1() { return cWriteCommandParserRuleCall_1; }
	}
	public class ReadCommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.ReadCommand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeiaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParamListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParamListDeclaredVarParserRuleCall_2_0 = (RuleCall)cParamListAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final RuleCall cEND_COMMANDTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//ReadCommand:
		//	'leia' '(' paramList=DeclaredVar ')' END_COMMAND;
		@Override public ParserRule getRule() { return rule; }
		
		//'leia' '(' paramList=DeclaredVar ')' END_COMMAND
		public Group getGroup() { return cGroup; }
		
		//'leia'
		public Keyword getLeiaKeyword_0() { return cLeiaKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//paramList=DeclaredVar
		public Assignment getParamListAssignment_2() { return cParamListAssignment_2; }
		
		//DeclaredVar
		public RuleCall getParamListDeclaredVarParserRuleCall_2_0() { return cParamListDeclaredVarParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_4() { return cEND_COMMANDTerminalRuleCall_4; }
	}
	public class WriteCommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.WriteCommand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEscrevaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cWriteParamAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cWriteParamWriteParamParserRuleCall_2_0 = (RuleCall)cWriteParamAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final RuleCall cEND_COMMANDTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//WriteCommand:
		//	'escreva' '(' writeParam=WriteParam ')' END_COMMAND;
		@Override public ParserRule getRule() { return rule; }
		
		//'escreva' '(' writeParam=WriteParam ')' END_COMMAND
		public Group getGroup() { return cGroup; }
		
		//'escreva'
		public Keyword getEscrevaKeyword_0() { return cEscrevaKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//writeParam=WriteParam
		public Assignment getWriteParamAssignment_2() { return cWriteParamAssignment_2; }
		
		//WriteParam
		public RuleCall getWriteParamWriteParamParserRuleCall_2_0() { return cWriteParamWriteParamParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_4() { return cEND_COMMANDTerminalRuleCall_4; }
	}
	public class WriteParamElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.WriteParam");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionExpressionParserRuleCall_0_0 = (RuleCall)cExpressionAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cExpressionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_1_0 = (RuleCall)cExpressionAssignment_1_1.eContents().get(0);
		private final Assignment cPrecisionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPrecisionOptDecimalPrecisionParserRuleCall_2_0 = (RuleCall)cPrecisionAssignment_2.eContents().get(0);
		
		//WriteParam:
		//	expression+=Expression (',' expression+=Expression)* precision=OptDecimalPrecision?;
		@Override public ParserRule getRule() { return rule; }
		
		//expression+=Expression (',' expression+=Expression)* precision=OptDecimalPrecision?
		public Group getGroup() { return cGroup; }
		
		//expression+=Expression
		public Assignment getExpressionAssignment_0() { return cExpressionAssignment_0; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_0_0() { return cExpressionExpressionParserRuleCall_0_0; }
		
		//(',' expression+=Expression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//expression+=Expression
		public Assignment getExpressionAssignment_1_1() { return cExpressionAssignment_1_1; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_1_0() { return cExpressionExpressionParserRuleCall_1_1_0; }
		
		//precision=OptDecimalPrecision?
		public Assignment getPrecisionAssignment_2() { return cPrecisionAssignment_2; }
		
		//OptDecimalPrecision
		public RuleCall getPrecisionOptDecimalPrecisionParserRuleCall_2_0() { return cPrecisionOptDecimalPrecisionParserRuleCall_2_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXorExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cExpressionLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final Keyword cOpORKeyword_1_0_1_0 = (Keyword)cOpAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightXorExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Expression:
		//	XorExpression (({Expression.left=current} op="OR") right=XorExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//XorExpression (({Expression.left=current} op="OR") right=XorExpression)*
		public Group getGroup() { return cGroup; }
		
		//XorExpression
		public RuleCall getXorExpressionParserRuleCall_0() { return cXorExpressionParserRuleCall_0; }
		
		//(({Expression.left=current} op="OR") right=XorExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({Expression.left=current} op="OR")
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{Expression.left=current}
		public Action getExpressionLeftAction_1_0_0() { return cExpressionLeftAction_1_0_0; }
		
		//op="OR"
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }
		
		//"OR"
		public Keyword getOpORKeyword_1_0_1_0() { return cOpORKeyword_1_0_1_0; }
		
		//right=XorExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//XorExpression
		public RuleCall getRightXorExpressionParserRuleCall_1_1_0() { return cRightXorExpressionParserRuleCall_1_1_0; }
	}
	public class XorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.XorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cXorExpressionLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final Keyword cOpXORKeyword_1_0_1_0 = (Keyword)cOpAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightAndExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//XorExpression Expression:
		//	AndExpression (({XorExpression.left=current} op="XOR") right=AndExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//AndExpression (({XorExpression.left=current} op="XOR") right=AndExpression)*
		public Group getGroup() { return cGroup; }
		
		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }
		
		//(({XorExpression.left=current} op="XOR") right=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({XorExpression.left=current} op="XOR")
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{XorExpression.left=current}
		public Action getXorExpressionLeftAction_1_0_0() { return cXorExpressionLeftAction_1_0_0; }
		
		//op="XOR"
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }
		
		//"XOR"
		public Keyword getOpXORKeyword_1_0_1_0() { return cOpXORKeyword_1_0_1_0; }
		
		//right=AndExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//AndExpression
		public RuleCall getRightAndExpressionParserRuleCall_1_1_0() { return cRightAndExpressionParserRuleCall_1_1_0; }
	}
	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cAndExpressionLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final Alternatives cOpAlternatives_1_0_1_0 = (Alternatives)cOpAssignment_1_0_1.eContents().get(0);
		private final Keyword cOpAmpersandKeyword_1_0_1_0_0 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(0);
		private final Keyword cOpANDKeyword_1_0_1_0_1 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightComparisonParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//AndExpression Expression:
		//	Comparison (({AndExpression.left=current} op=('&' | 'AND')) right=Comparison)*
		@Override public ParserRule getRule() { return rule; }
		
		//Comparison (({AndExpression.left=current} op=('&' | 'AND')) right=Comparison)*
		public Group getGroup() { return cGroup; }
		
		//Comparison
		public RuleCall getComparisonParserRuleCall_0() { return cComparisonParserRuleCall_0; }
		
		//(({AndExpression.left=current} op=('&' | 'AND')) right=Comparison)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({AndExpression.left=current} op=('&' | 'AND'))
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{AndExpression.left=current}
		public Action getAndExpressionLeftAction_1_0_0() { return cAndExpressionLeftAction_1_0_0; }
		
		//op=('&' | 'AND')
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }
		
		//('&' | 'AND')
		public Alternatives getOpAlternatives_1_0_1_0() { return cOpAlternatives_1_0_1_0; }
		
		//'&'
		public Keyword getOpAmpersandKeyword_1_0_1_0_0() { return cOpAmpersandKeyword_1_0_1_0_0; }
		
		//'AND'
		public Keyword getOpANDKeyword_1_0_1_0_1() { return cOpANDKeyword_1_0_1_0_1; }
		
		//right=Comparison
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//Comparison
		public RuleCall getRightComparisonParserRuleCall_1_1_0() { return cRightComparisonParserRuleCall_1_1_0; }
	}
	public class ComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Comparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEquExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cCompExpressionLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final Alternatives cOpAlternatives_1_0_1_0 = (Alternatives)cOpAssignment_1_0_1.eContents().get(0);
		private final Keyword cOpEqualsSignKeyword_1_0_1_0_0 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(0);
		private final Keyword cOpLessThanSignGreaterThanSignKeyword_1_0_1_0_1 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightEquExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Comparison Expression:
		//	EquExpression (({CompExpression.left=current} op=('=' | '<>')) right=EquExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//EquExpression (({CompExpression.left=current} op=('=' | '<>')) right=EquExpression)*
		public Group getGroup() { return cGroup; }
		
		//EquExpression
		public RuleCall getEquExpressionParserRuleCall_0() { return cEquExpressionParserRuleCall_0; }
		
		//(({CompExpression.left=current} op=('=' | '<>')) right=EquExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({CompExpression.left=current} op=('=' | '<>'))
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{CompExpression.left=current}
		public Action getCompExpressionLeftAction_1_0_0() { return cCompExpressionLeftAction_1_0_0; }
		
		//op=('=' | '<>')
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }
		
		//('=' | '<>')
		public Alternatives getOpAlternatives_1_0_1_0() { return cOpAlternatives_1_0_1_0; }
		
		//'='
		public Keyword getOpEqualsSignKeyword_1_0_1_0_0() { return cOpEqualsSignKeyword_1_0_1_0_0; }
		
		//'<>'
		public Keyword getOpLessThanSignGreaterThanSignKeyword_1_0_1_0_1() { return cOpLessThanSignGreaterThanSignKeyword_1_0_1_0_1; }
		
		//right=EquExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//EquExpression
		public RuleCall getRightEquExpressionParserRuleCall_1_1_0() { return cRightEquExpressionParserRuleCall_1_1_0; }
	}
	public class EquExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.EquExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAddExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cEquExpressionLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final Alternatives cOpAlternatives_1_0_1_0 = (Alternatives)cOpAssignment_1_0_1.eContents().get(0);
		private final Keyword cOpLessThanSignKeyword_1_0_1_0_0 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(0);
		private final Keyword cOpGreaterThanSignKeyword_1_0_1_0_1 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(1);
		private final Keyword cOpLessThanSignEqualsSignKeyword_1_0_1_0_2 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(2);
		private final Keyword cOpGreaterThanSignEqualsSignKeyword_1_0_1_0_3 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(3);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightAddExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//EquExpression Expression:
		//	AddExpression (({EquExpression.left=current} op=('<' | '>' | '<=' | '>=')) right=AddExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//AddExpression (({EquExpression.left=current} op=('<' | '>' | '<=' | '>=')) right=AddExpression)*
		public Group getGroup() { return cGroup; }
		
		//AddExpression
		public RuleCall getAddExpressionParserRuleCall_0() { return cAddExpressionParserRuleCall_0; }
		
		//(({EquExpression.left=current} op=('<' | '>' | '<=' | '>=')) right=AddExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({EquExpression.left=current} op=('<' | '>' | '<=' | '>='))
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{EquExpression.left=current}
		public Action getEquExpressionLeftAction_1_0_0() { return cEquExpressionLeftAction_1_0_0; }
		
		//op=('<' | '>' | '<=' | '>=')
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }
		
		//('<' | '>' | '<=' | '>=')
		public Alternatives getOpAlternatives_1_0_1_0() { return cOpAlternatives_1_0_1_0; }
		
		//'<'
		public Keyword getOpLessThanSignKeyword_1_0_1_0_0() { return cOpLessThanSignKeyword_1_0_1_0_0; }
		
		//'>'
		public Keyword getOpGreaterThanSignKeyword_1_0_1_0_1() { return cOpGreaterThanSignKeyword_1_0_1_0_1; }
		
		//'<='
		public Keyword getOpLessThanSignEqualsSignKeyword_1_0_1_0_2() { return cOpLessThanSignEqualsSignKeyword_1_0_1_0_2; }
		
		//'>='
		public Keyword getOpGreaterThanSignEqualsSignKeyword_1_0_1_0_3() { return cOpGreaterThanSignEqualsSignKeyword_1_0_1_0_3; }
		
		//right=AddExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//AddExpression
		public RuleCall getRightAddExpressionParserRuleCall_1_1_0() { return cRightAddExpressionParserRuleCall_1_1_0; }
	}
	public class AddExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.AddExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTermParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cAddExpressionLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cSubExpressionLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightTermParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//AddExpression Expression:
		//	Term (({AddExpression.left=current} '+' | {SubExpression.left=current} '-') right=Term)*
		@Override public ParserRule getRule() { return rule; }
		
		//Term (({AddExpression.left=current} '+' | {SubExpression.left=current} '-') right=Term)*
		public Group getGroup() { return cGroup; }
		
		//Term
		public RuleCall getTermParserRuleCall_0() { return cTermParserRuleCall_0; }
		
		//(({AddExpression.left=current} '+' | {SubExpression.left=current} '-') right=Term)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({AddExpression.left=current} '+' | {SubExpression.left=current} '-')
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//{AddExpression.left=current} '+'
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{AddExpression.left=current}
		public Action getAddExpressionLeftAction_1_0_0_0() { return cAddExpressionLeftAction_1_0_0_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_1_0_0_1() { return cPlusSignKeyword_1_0_0_1; }
		
		//{SubExpression.left=current} '-'
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//{SubExpression.left=current}
		public Action getSubExpressionLeftAction_1_0_1_0() { return cSubExpressionLeftAction_1_0_1_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1_0_1_1() { return cHyphenMinusKeyword_1_0_1_1; }
		
		//right=Term
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//Term
		public RuleCall getRightTermParserRuleCall_1_1_0() { return cRightTermParserRuleCall_1_1_0; }
	}
	public class TermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Term");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPowerExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cMultiplyLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cDivisionLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cAlternatives_1_0.eContents().get(2);
		private final Action cModLeftAction_1_0_2_0 = (Action)cGroup_1_0_2.eContents().get(0);
		private final Keyword cMODKeyword_1_0_2_1 = (Keyword)cGroup_1_0_2.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightPowerExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Term Expression:
		//	PowerExpression (({Multiply.left=current} '*' | {Division.left=current} '/' | {Mod.left=current} 'MOD')
		//	right=PowerExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//PowerExpression (({Multiply.left=current} '*' | {Division.left=current} '/' | {Mod.left=current} 'MOD')
		//right=PowerExpression)*
		public Group getGroup() { return cGroup; }
		
		//PowerExpression
		public RuleCall getPowerExpressionParserRuleCall_0() { return cPowerExpressionParserRuleCall_0; }
		
		//(({Multiply.left=current} '*' | {Division.left=current} '/' | {Mod.left=current} 'MOD') right=PowerExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({Multiply.left=current} '*' | {Division.left=current} '/' | {Mod.left=current} 'MOD')
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//{Multiply.left=current} '*'
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{Multiply.left=current}
		public Action getMultiplyLeftAction_1_0_0_0() { return cMultiplyLeftAction_1_0_0_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_1_0_0_1() { return cAsteriskKeyword_1_0_0_1; }
		
		//{Division.left=current} '/'
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//{Division.left=current}
		public Action getDivisionLeftAction_1_0_1_0() { return cDivisionLeftAction_1_0_1_0; }
		
		//'/'
		public Keyword getSolidusKeyword_1_0_1_1() { return cSolidusKeyword_1_0_1_1; }
		
		//{Mod.left=current} 'MOD'
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }
		
		//{Mod.left=current}
		public Action getModLeftAction_1_0_2_0() { return cModLeftAction_1_0_2_0; }
		
		//'MOD'
		public Keyword getMODKeyword_1_0_2_1() { return cMODKeyword_1_0_2_1; }
		
		//right=PowerExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//PowerExpression
		public RuleCall getRightPowerExpressionParserRuleCall_1_1_0() { return cRightPowerExpressionParserRuleCall_1_1_0; }
	}
	public class PowerExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.PowerExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPowerExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpCircumflexAccentKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightUnaryExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//PowerExpression Expression:
		//	UnaryExpression ({PowerExpression.left=current} op='^' right=UnaryExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//UnaryExpression ({PowerExpression.left=current} op='^' right=UnaryExpression)*
		public Group getGroup() { return cGroup; }
		
		//UnaryExpression
		public RuleCall getUnaryExpressionParserRuleCall_0() { return cUnaryExpressionParserRuleCall_0; }
		
		//({PowerExpression.left=current} op='^' right=UnaryExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{PowerExpression.left=current}
		public Action getPowerExpressionLeftAction_1_0() { return cPowerExpressionLeftAction_1_0; }
		
		//op='^'
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//'^'
		public Keyword getOpCircumflexAccentKeyword_1_1_0() { return cOpCircumflexAccentKeyword_1_1_0; }
		
		//right=UnaryExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//UnaryExpression
		public RuleCall getRightUnaryExpressionParserRuleCall_1_2_0() { return cRightUnaryExpressionParserRuleCall_1_2_0; }
	}
	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.UnaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBooleanNegationAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cNOTKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cExpressionAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cExpressionPrimaryExpressionParserRuleCall_0_2_0 = (RuleCall)cExpressionAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cArithmeticSignedAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionPrimaryExpressionParserRuleCall_1_2_0 = (RuleCall)cExpressionAssignment_1_2.eContents().get(0);
		private final RuleCall cPrimaryExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//UnaryExpression Expression:
		//	{BooleanNegation} => "NOT" expression=PrimaryExpression / * right associativity * /
		//	| {ArithmeticSigned} => "-" expression=PrimaryExpression / * right associativity * /
		//	| PrimaryExpression
		@Override public ParserRule getRule() { return rule; }
		
		//{BooleanNegation} => "NOT" expression=PrimaryExpression / * right associativity * / | {ArithmeticSigned} => "-"
		//expression=PrimaryExpression / * right associativity * / | PrimaryExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{BooleanNegation} => "NOT" expression=PrimaryExpression
		public Group getGroup_0() { return cGroup_0; }
		
		//{BooleanNegation}
		public Action getBooleanNegationAction_0_0() { return cBooleanNegationAction_0_0; }
		
		//=> "NOT"
		public Keyword getNOTKeyword_0_1() { return cNOTKeyword_0_1; }
		
		//expression=PrimaryExpression
		public Assignment getExpressionAssignment_0_2() { return cExpressionAssignment_0_2; }
		
		//PrimaryExpression
		public RuleCall getExpressionPrimaryExpressionParserRuleCall_0_2_0() { return cExpressionPrimaryExpressionParserRuleCall_0_2_0; }
		
		//{ArithmeticSigned} => "-" expression=PrimaryExpression
		public Group getGroup_1() { return cGroup_1; }
		
		//{ArithmeticSigned}
		public Action getArithmeticSignedAction_1_0() { return cArithmeticSignedAction_1_0; }
		
		//=> "-"
		public Keyword getHyphenMinusKeyword_1_1() { return cHyphenMinusKeyword_1_1; }
		
		//expression=PrimaryExpression
		public Assignment getExpressionAssignment_1_2() { return cExpressionAssignment_1_2; }
		
		//PrimaryExpression
		public RuleCall getExpressionPrimaryExpressionParserRuleCall_1_2_0() { return cExpressionPrimaryExpressionParserRuleCall_1_2_0; }
		
		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_2() { return cPrimaryExpressionParserRuleCall_2; }
	}
	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cExpressionConstantAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cValueConstantParserRuleCall_0_1_0 = (RuleCall)cValueAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cExpressionVariableAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final CrossReference cValueVarNameCrossReference_1_1_0 = (CrossReference)cValueAssignment_1_1.eContents().get(0);
		private final RuleCall cValueVarNameIDTerminalRuleCall_1_1_0_1 = (RuleCall)cValueVarNameCrossReference_1_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final RuleCall cFunctionCallParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//PrimaryExpression Expression:
		//	{ExpressionConstant} value=Constant
		//	| {ExpressionVariable} value=[VarName] | '(' Expression ')'
		//	| FunctionCall
		@Override public ParserRule getRule() { return rule; }
		
		//{ExpressionConstant} value=Constant | {ExpressionVariable} value=[VarName] | '(' Expression ')' | FunctionCall
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{ExpressionConstant} value=Constant
		public Group getGroup_0() { return cGroup_0; }
		
		//{ExpressionConstant}
		public Action getExpressionConstantAction_0_0() { return cExpressionConstantAction_0_0; }
		
		//value=Constant
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }
		
		//Constant
		public RuleCall getValueConstantParserRuleCall_0_1_0() { return cValueConstantParserRuleCall_0_1_0; }
		
		//{ExpressionVariable} value=[VarName]
		public Group getGroup_1() { return cGroup_1; }
		
		//{ExpressionVariable}
		public Action getExpressionVariableAction_1_0() { return cExpressionVariableAction_1_0; }
		
		//value=[VarName]
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//[VarName]
		public CrossReference getValueVarNameCrossReference_1_1_0() { return cValueVarNameCrossReference_1_1_0; }
		
		//ID
		public RuleCall getValueVarNameIDTerminalRuleCall_1_1_0_1() { return cValueVarNameIDTerminalRuleCall_1_1_0_1; }
		
		//'(' Expression ')'
		public Group getGroup_2() { return cGroup_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_2_1() { return cExpressionParserRuleCall_2_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
		
		//FunctionCall
		public RuleCall getFunctionCallParserRuleCall_3() { return cFunctionCallParserRuleCall_3; }
	}
	public class FunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.FunctionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFbNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cFbNameFunctionNameCrossReference_0_0 = (CrossReference)cFbNameAssignment_0.eContents().get(0);
		private final RuleCall cFbNameFunctionNameIDTerminalRuleCall_0_0_1 = (RuleCall)cFbNameFunctionNameCrossReference_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParamAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParamWriteParamParserRuleCall_2_0 = (RuleCall)cParamAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//FunctionCall:
		//	fbName=[FunctionName] '(' param=WriteParam ')';
		@Override public ParserRule getRule() { return rule; }
		
		//fbName=[FunctionName] '(' param=WriteParam ')'
		public Group getGroup() { return cGroup; }
		
		//fbName=[FunctionName]
		public Assignment getFbNameAssignment_0() { return cFbNameAssignment_0; }
		
		//[FunctionName]
		public CrossReference getFbNameFunctionNameCrossReference_0_0() { return cFbNameFunctionNameCrossReference_0_0; }
		
		//ID
		public RuleCall getFbNameFunctionNameIDTerminalRuleCall_0_0_1() { return cFbNameFunctionNameIDTerminalRuleCall_0_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//param=WriteParam
		public Assignment getParamAssignment_2() { return cParamAssignment_2; }
		
		//WriteParam
		public RuleCall getParamWriteParamParserRuleCall_2_0() { return cParamWriteParamParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class OptDecimalPrecisionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.OptDecimalPrecision");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFirstPrecisionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFirstPrecisionINTTerminalRuleCall_1_0 = (RuleCall)cFirstPrecisionAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cSecondPrecisionAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cSecondPrecisionINTTerminalRuleCall_2_1_0 = (RuleCall)cSecondPrecisionAssignment_2_1.eContents().get(0);
		
		//OptDecimalPrecision:
		//	':' firstPrecision=INT (':' secondPrecision=INT)?;
		@Override public ParserRule getRule() { return rule; }
		
		//':' firstPrecision=INT (':' secondPrecision=INT)?
		public Group getGroup() { return cGroup; }
		
		//':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//firstPrecision=INT
		public Assignment getFirstPrecisionAssignment_1() { return cFirstPrecisionAssignment_1; }
		
		//INT
		public RuleCall getFirstPrecisionINTTerminalRuleCall_1_0() { return cFirstPrecisionINTTerminalRuleCall_1_0; }
		
		//(':' secondPrecision=INT)?
		public Group getGroup_2() { return cGroup_2; }
		
		//':'
		public Keyword getColonKeyword_2_0() { return cColonKeyword_2_0; }
		
		//secondPrecision=INT
		public Assignment getSecondPrecisionAssignment_2_1() { return cSecondPrecisionAssignment_2_1; }
		
		//INT
		public RuleCall getSecondPrecisionINTTerminalRuleCall_2_1_0() { return cSecondPrecisionINTTerminalRuleCall_2_1_0; }
	}
	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Constant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumericLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Constant:
		//	NumericLiteral | StringExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//NumericLiteral | StringExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//NumericLiteral
		public RuleCall getNumericLiteralParserRuleCall_0() { return cNumericLiteralParserRuleCall_0; }
		
		//StringExpression
		public RuleCall getStringExpressionParserRuleCall_1() { return cStringExpressionParserRuleCall_1; }
	}
	public class NumericLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.NumericLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cIntValueAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cIntValueINTTerminalRuleCall_0_0 = (RuleCall)cIntValueAssignment_0.eContents().get(0);
		private final Assignment cFloatValueAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cFloatValueFLOATTerminalRuleCall_1_0 = (RuleCall)cFloatValueAssignment_1.eContents().get(0);
		
		//NumericLiteral:
		//	intValue?=INT
		//	| floatValue?=FLOAT;
		@Override public ParserRule getRule() { return rule; }
		
		//intValue?=INT | floatValue?=FLOAT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//intValue?=INT
		public Assignment getIntValueAssignment_0() { return cIntValueAssignment_0; }
		
		//INT
		public RuleCall getIntValueINTTerminalRuleCall_0_0() { return cIntValueINTTerminalRuleCall_0_0; }
		
		//floatValue?=FLOAT
		public Assignment getFloatValueAssignment_1() { return cFloatValueAssignment_1; }
		
		//FLOAT
		public RuleCall getFloatValueFLOATTerminalRuleCall_1_0() { return cFloatValueFLOATTerminalRuleCall_1_0; }
	}
	public class StringExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.StringExpression");
		private final Assignment cLiteralStringAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cLiteralStringSTRINGTerminalRuleCall_0 = (RuleCall)cLiteralStringAssignment.eContents().get(0);
		
		//StringExpression:
		//	literalString=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//literalString=STRING
		public Assignment getLiteralStringAssignment() { return cLiteralStringAssignment; }
		
		//STRING
		public RuleCall getLiteralStringSTRINGTerminalRuleCall_0() { return cLiteralStringSTRINGTerminalRuleCall_0; }
	}
	
	
	private final ModelElements pModel;
	private final HeaderBlockElements pHeaderBlock;
	private final DeclarationsBlockElements pDeclarationsBlock;
	private final VariableElements pVariable;
	private final VarDeclarationElements pVarDeclaration;
	private final DeclaredVarElements pDeclaredVar;
	private final VarNameElements pVarName;
	private final VarTypeElements pVarType;
	private final SubprogramsElements pSubprograms;
	private final BlockSubProgramsElements pBlockSubPrograms;
	private final FunctionNameElements pFunctionName;
	private final ProcedureNameElements pProcedureName;
	private final BlockFunctionElements pBlockFunction;
	private final BlockProcedureElements pBlockProcedure;
	private final BlockCommandElements pBlockCommand;
	private final AbstractCommandElements pAbstractCommand;
	private final ReadCommandElements pReadCommand;
	private final WriteCommandElements pWriteCommand;
	private final WriteParamElements pWriteParam;
	private final ExpressionElements pExpression;
	private final XorExpressionElements pXorExpression;
	private final AndExpressionElements pAndExpression;
	private final ComparisonElements pComparison;
	private final EquExpressionElements pEquExpression;
	private final AddExpressionElements pAddExpression;
	private final TermElements pTerm;
	private final PowerExpressionElements pPowerExpression;
	private final UnaryExpressionElements pUnaryExpression;
	private final PrimaryExpressionElements pPrimaryExpression;
	private final FunctionCallElements pFunctionCall;
	private final OptDecimalPrecisionElements pOptDecimalPrecision;
	private final ConstantElements pConstant;
	private final NumericLiteralElements pNumericLiteral;
	private final StringExpressionElements pStringExpression;
	private final TerminalRule tFLOAT;
	private final TerminalRule tEND_COMMAND;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public PortugolGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pHeaderBlock = new HeaderBlockElements();
		this.pDeclarationsBlock = new DeclarationsBlockElements();
		this.pVariable = new VariableElements();
		this.pVarDeclaration = new VarDeclarationElements();
		this.pDeclaredVar = new DeclaredVarElements();
		this.pVarName = new VarNameElements();
		this.pVarType = new VarTypeElements();
		this.pSubprograms = new SubprogramsElements();
		this.pBlockSubPrograms = new BlockSubProgramsElements();
		this.pFunctionName = new FunctionNameElements();
		this.pProcedureName = new ProcedureNameElements();
		this.pBlockFunction = new BlockFunctionElements();
		this.pBlockProcedure = new BlockProcedureElements();
		this.pBlockCommand = new BlockCommandElements();
		this.pAbstractCommand = new AbstractCommandElements();
		this.pReadCommand = new ReadCommandElements();
		this.pWriteCommand = new WriteCommandElements();
		this.pWriteParam = new WriteParamElements();
		this.pExpression = new ExpressionElements();
		this.pXorExpression = new XorExpressionElements();
		this.pAndExpression = new AndExpressionElements();
		this.pComparison = new ComparisonElements();
		this.pEquExpression = new EquExpressionElements();
		this.pAddExpression = new AddExpressionElements();
		this.pTerm = new TermElements();
		this.pPowerExpression = new PowerExpressionElements();
		this.pUnaryExpression = new UnaryExpressionElements();
		this.pPrimaryExpression = new PrimaryExpressionElements();
		this.pFunctionCall = new FunctionCallElements();
		this.pOptDecimalPrecision = new OptDecimalPrecisionElements();
		this.pConstant = new ConstantElements();
		this.pNumericLiteral = new NumericLiteralElements();
		this.pStringExpression = new StringExpressionElements();
		this.tFLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.FLOAT");
		this.tEND_COMMAND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.END_COMMAND");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.hopper.language.Portugol".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	header=HeaderBlock
	//	globalDeclarations=DeclarationsBlock
	//	subprograms=Subprograms?
	//	commands=BlockCommand;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	//HeaderBlock:
	//	'algoritmo' name=STRING END_COMMAND;
	public HeaderBlockElements getHeaderBlockAccess() {
		return pHeaderBlock;
	}
	
	public ParserRule getHeaderBlockRule() {
		return getHeaderBlockAccess().getRule();
	}
	
	//DeclarationsBlock:
	//	'var' END_COMMAND (vars+=Variable END_COMMAND)+;
	public DeclarationsBlockElements getDeclarationsBlockAccess() {
		return pDeclarationsBlock;
	}
	
	public ParserRule getDeclarationsBlockRule() {
		return getDeclarationsBlockAccess().getRule();
	}
	
	//Variable:
	//	varDeclaration=VarDeclaration ':' type=VarType;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//VarDeclaration:
	//	vars+=VarName (',' vars+=VarName)*;
	public VarDeclarationElements getVarDeclarationAccess() {
		return pVarDeclaration;
	}
	
	public ParserRule getVarDeclarationRule() {
		return getVarDeclarationAccess().getRule();
	}
	
	//DeclaredVar:
	//	vars+=[VarName] (',' vars+=[VarName])*;
	public DeclaredVarElements getDeclaredVarAccess() {
		return pDeclaredVar;
	}
	
	public ParserRule getDeclaredVarRule() {
		return getDeclaredVarAccess().getRule();
	}
	
	//VarName:
	//	name=ID;
	public VarNameElements getVarNameAccess() {
		return pVarName;
	}
	
	public ParserRule getVarNameRule() {
		return getVarNameAccess().getRule();
	}
	
	//VarType:
	//	typeName=('real' | 'inteiro' | 'caractere');
	public VarTypeElements getVarTypeAccess() {
		return pVarType;
	}
	
	public ParserRule getVarTypeRule() {
		return getVarTypeAccess().getRule();
	}
	
	//Subprograms:
	//	blockSubPrograms+=BlockSubPrograms+;
	public SubprogramsElements getSubprogramsAccess() {
		return pSubprograms;
	}
	
	public ParserRule getSubprogramsRule() {
		return getSubprogramsAccess().getRule();
	}
	
	//BlockSubPrograms:
	//	BlockFunction | BlockProcedure;
	public BlockSubProgramsElements getBlockSubProgramsAccess() {
		return pBlockSubPrograms;
	}
	
	public ParserRule getBlockSubProgramsRule() {
		return getBlockSubProgramsAccess().getRule();
	}
	
	//FunctionName:
	//	name=ID;
	public FunctionNameElements getFunctionNameAccess() {
		return pFunctionName;
	}
	
	public ParserRule getFunctionNameRule() {
		return getFunctionNameAccess().getRule();
	}
	
	//ProcedureName:
	//	name=ID;
	public ProcedureNameElements getProcedureNameAccess() {
		return pProcedureName;
	}
	
	public ParserRule getProcedureNameRule() {
		return getProcedureNameAccess().getRule();
	}
	
	//BlockFunction:
	//	'funcao' functionName=FunctionName '(' paramList=Variable ')' ':' returnType=VarType END_COMMAND
	//	declarations=DeclarationsBlock?
	//	'inicio' END_COMMAND
	//	commands+=AbstractCommand+
	//	'fimfuncao' END_COMMAND;
	public BlockFunctionElements getBlockFunctionAccess() {
		return pBlockFunction;
	}
	
	public ParserRule getBlockFunctionRule() {
		return getBlockFunctionAccess().getRule();
	}
	
	//BlockProcedure:
	//	'procedimento' procedure=ProcedureName '(' paramList=Variable ')' END_COMMAND
	//	declarations=DeclarationsBlock?
	//	'inicio' END_COMMAND
	//	commands+=AbstractCommand+
	//	'fimprocedimento' END_COMMAND;
	public BlockProcedureElements getBlockProcedureAccess() {
		return pBlockProcedure;
	}
	
	public ParserRule getBlockProcedureRule() {
		return getBlockProcedureAccess().getRule();
	}
	
	//BlockCommand:
	//	'inicio' END_COMMAND
	//	commands+=AbstractCommand+
	//	'fimalgoritmo' END_COMMAND;
	public BlockCommandElements getBlockCommandAccess() {
		return pBlockCommand;
	}
	
	public ParserRule getBlockCommandRule() {
		return getBlockCommandAccess().getRule();
	}
	
	//AbstractCommand:
	//	ReadCommand
	//	| WriteCommand;
	public AbstractCommandElements getAbstractCommandAccess() {
		return pAbstractCommand;
	}
	
	public ParserRule getAbstractCommandRule() {
		return getAbstractCommandAccess().getRule();
	}
	
	//ReadCommand:
	//	'leia' '(' paramList=DeclaredVar ')' END_COMMAND;
	public ReadCommandElements getReadCommandAccess() {
		return pReadCommand;
	}
	
	public ParserRule getReadCommandRule() {
		return getReadCommandAccess().getRule();
	}
	
	//WriteCommand:
	//	'escreva' '(' writeParam=WriteParam ')' END_COMMAND;
	public WriteCommandElements getWriteCommandAccess() {
		return pWriteCommand;
	}
	
	public ParserRule getWriteCommandRule() {
		return getWriteCommandAccess().getRule();
	}
	
	//WriteParam:
	//	expression+=Expression (',' expression+=Expression)* precision=OptDecimalPrecision?;
	public WriteParamElements getWriteParamAccess() {
		return pWriteParam;
	}
	
	public ParserRule getWriteParamRule() {
		return getWriteParamAccess().getRule();
	}
	
	//Expression:
	//	XorExpression (({Expression.left=current} op="OR") right=XorExpression)*;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//XorExpression Expression:
	//	AndExpression (({XorExpression.left=current} op="XOR") right=AndExpression)*
	public XorExpressionElements getXorExpressionAccess() {
		return pXorExpression;
	}
	
	public ParserRule getXorExpressionRule() {
		return getXorExpressionAccess().getRule();
	}
	
	//AndExpression Expression:
	//	Comparison (({AndExpression.left=current} op=('&' | 'AND')) right=Comparison)*
	public AndExpressionElements getAndExpressionAccess() {
		return pAndExpression;
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}
	
	//Comparison Expression:
	//	EquExpression (({CompExpression.left=current} op=('=' | '<>')) right=EquExpression)*
	public ComparisonElements getComparisonAccess() {
		return pComparison;
	}
	
	public ParserRule getComparisonRule() {
		return getComparisonAccess().getRule();
	}
	
	//EquExpression Expression:
	//	AddExpression (({EquExpression.left=current} op=('<' | '>' | '<=' | '>=')) right=AddExpression)*
	public EquExpressionElements getEquExpressionAccess() {
		return pEquExpression;
	}
	
	public ParserRule getEquExpressionRule() {
		return getEquExpressionAccess().getRule();
	}
	
	//AddExpression Expression:
	//	Term (({AddExpression.left=current} '+' | {SubExpression.left=current} '-') right=Term)*
	public AddExpressionElements getAddExpressionAccess() {
		return pAddExpression;
	}
	
	public ParserRule getAddExpressionRule() {
		return getAddExpressionAccess().getRule();
	}
	
	//Term Expression:
	//	PowerExpression (({Multiply.left=current} '*' | {Division.left=current} '/' | {Mod.left=current} 'MOD')
	//	right=PowerExpression)*
	public TermElements getTermAccess() {
		return pTerm;
	}
	
	public ParserRule getTermRule() {
		return getTermAccess().getRule();
	}
	
	//PowerExpression Expression:
	//	UnaryExpression ({PowerExpression.left=current} op='^' right=UnaryExpression)*
	public PowerExpressionElements getPowerExpressionAccess() {
		return pPowerExpression;
	}
	
	public ParserRule getPowerExpressionRule() {
		return getPowerExpressionAccess().getRule();
	}
	
	//UnaryExpression Expression:
	//	{BooleanNegation} => "NOT" expression=PrimaryExpression / * right associativity * /
	//	| {ArithmeticSigned} => "-" expression=PrimaryExpression / * right associativity * /
	//	| PrimaryExpression
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return pUnaryExpression;
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}
	
	//PrimaryExpression Expression:
	//	{ExpressionConstant} value=Constant
	//	| {ExpressionVariable} value=[VarName] | '(' Expression ')'
	//	| FunctionCall
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return pPrimaryExpression;
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}
	
	//FunctionCall:
	//	fbName=[FunctionName] '(' param=WriteParam ')';
	public FunctionCallElements getFunctionCallAccess() {
		return pFunctionCall;
	}
	
	public ParserRule getFunctionCallRule() {
		return getFunctionCallAccess().getRule();
	}
	
	//OptDecimalPrecision:
	//	':' firstPrecision=INT (':' secondPrecision=INT)?;
	public OptDecimalPrecisionElements getOptDecimalPrecisionAccess() {
		return pOptDecimalPrecision;
	}
	
	public ParserRule getOptDecimalPrecisionRule() {
		return getOptDecimalPrecisionAccess().getRule();
	}
	
	//Constant:
	//	NumericLiteral | StringExpression;
	public ConstantElements getConstantAccess() {
		return pConstant;
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}
	
	//NumericLiteral:
	//	intValue?=INT
	//	| floatValue?=FLOAT;
	public NumericLiteralElements getNumericLiteralAccess() {
		return pNumericLiteral;
	}
	
	public ParserRule getNumericLiteralRule() {
		return getNumericLiteralAccess().getRule();
	}
	
	//StringExpression:
	//	literalString=STRING;
	public StringExpressionElements getStringExpressionAccess() {
		return pStringExpression;
	}
	
	public ParserRule getStringExpressionRule() {
		return getStringExpressionAccess().getRule();
	}
	
	//terminal FLOAT:
	//	INT '.' INT;
	public TerminalRule getFLOATRule() {
		return tFLOAT;
	}
	
	//terminal END_COMMAND:
	//	(' ' | '\t')* ('\r' | '\n')+ (' ' | '\t')*;
	public TerminalRule getEND_COMMANDRule() {
		return tEND_COMMAND;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}

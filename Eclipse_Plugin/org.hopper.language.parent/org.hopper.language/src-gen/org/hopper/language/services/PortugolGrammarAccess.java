/*
 * generated by Xtext 2.9.0
 */
package org.hopper.language.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class PortugolGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cHeaderAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cHeaderHeaderBlockParserRuleCall_0_0 = (RuleCall)cHeaderAssignment_0.eContents().get(0);
		private final Assignment cGlobalDeclarationsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cGlobalDeclarationsDeclarationsBlockParserRuleCall_1_0 = (RuleCall)cGlobalDeclarationsAssignment_1.eContents().get(0);
		private final Assignment cSubprogramsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSubprogramsSubprogramsParserRuleCall_2_0 = (RuleCall)cSubprogramsAssignment_2.eContents().get(0);
		private final Assignment cCommandsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCommandsBlockCommandParserRuleCall_3_0 = (RuleCall)cCommandsAssignment_3.eContents().get(0);
		
		//Model:
		//	header=HeaderBlock
		//	globalDeclarations=DeclarationsBlock?
		//	subprograms=Subprograms?
		//	commands=BlockCommand;
		@Override public ParserRule getRule() { return rule; }
		
		//header=HeaderBlock globalDeclarations=DeclarationsBlock? subprograms=Subprograms? commands=BlockCommand
		public Group getGroup() { return cGroup; }
		
		//header=HeaderBlock
		public Assignment getHeaderAssignment_0() { return cHeaderAssignment_0; }
		
		//HeaderBlock
		public RuleCall getHeaderHeaderBlockParserRuleCall_0_0() { return cHeaderHeaderBlockParserRuleCall_0_0; }
		
		//globalDeclarations=DeclarationsBlock?
		public Assignment getGlobalDeclarationsAssignment_1() { return cGlobalDeclarationsAssignment_1; }
		
		//DeclarationsBlock
		public RuleCall getGlobalDeclarationsDeclarationsBlockParserRuleCall_1_0() { return cGlobalDeclarationsDeclarationsBlockParserRuleCall_1_0; }
		
		//subprograms=Subprograms?
		public Assignment getSubprogramsAssignment_2() { return cSubprogramsAssignment_2; }
		
		//Subprograms
		public RuleCall getSubprogramsSubprogramsParserRuleCall_2_0() { return cSubprogramsSubprogramsParserRuleCall_2_0; }
		
		//commands=BlockCommand
		public Assignment getCommandsAssignment_3() { return cCommandsAssignment_3; }
		
		//BlockCommand
		public RuleCall getCommandsBlockCommandParserRuleCall_3_0() { return cCommandsBlockCommandParserRuleCall_3_0; }
	}
	public class HeaderBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.HeaderBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAlgoritmoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cAlgorithmNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAlgorithmNameSTRINGTerminalRuleCall_1_0 = (RuleCall)cAlgorithmNameAssignment_1.eContents().get(0);
		private final RuleCall cEND_COMMANDParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//HeaderBlock:
		//	'algoritmo' algorithmName=STRING END_COMMAND;
		@Override public ParserRule getRule() { return rule; }
		
		//'algoritmo' algorithmName=STRING END_COMMAND
		public Group getGroup() { return cGroup; }
		
		//'algoritmo'
		public Keyword getAlgoritmoKeyword_0() { return cAlgoritmoKeyword_0; }
		
		//algorithmName=STRING
		public Assignment getAlgorithmNameAssignment_1() { return cAlgorithmNameAssignment_1; }
		
		//STRING
		public RuleCall getAlgorithmNameSTRINGTerminalRuleCall_1_0() { return cAlgorithmNameSTRINGTerminalRuleCall_1_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDParserRuleCall_2() { return cEND_COMMANDParserRuleCall_2; }
	}
	public class DeclarationsBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.DeclarationsBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVarKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cVarsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cVarsVariableParserRuleCall_1_0_0 = (RuleCall)cVarsAssignment_1_0.eContents().get(0);
		private final RuleCall cEND_COMMANDParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//DeclarationsBlock:
		//	'var' (vars+=Variable END_COMMAND)+;
		@Override public ParserRule getRule() { return rule; }
		
		//'var' (vars+=Variable END_COMMAND)+
		public Group getGroup() { return cGroup; }
		
		//'var'
		public Keyword getVarKeyword_0() { return cVarKeyword_0; }
		
		//(vars+=Variable END_COMMAND)+
		public Group getGroup_1() { return cGroup_1; }
		
		//vars+=Variable
		public Assignment getVarsAssignment_1_0() { return cVarsAssignment_1_0; }
		
		//Variable
		public RuleCall getVarsVariableParserRuleCall_1_0_0() { return cVarsVariableParserRuleCall_1_0_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDParserRuleCall_1_1() { return cEND_COMMANDParserRuleCall_1_1; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarDeclarationAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarDeclarationVarDeclarationParserRuleCall_0_0 = (RuleCall)cVarDeclarationAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeVarTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//Variable:
		//	varDeclaration=VarDeclaration ':' type=VarType;
		@Override public ParserRule getRule() { return rule; }
		
		//varDeclaration=VarDeclaration ':' type=VarType
		public Group getGroup() { return cGroup; }
		
		//varDeclaration=VarDeclaration
		public Assignment getVarDeclarationAssignment_0() { return cVarDeclarationAssignment_0; }
		
		//VarDeclaration
		public RuleCall getVarDeclarationVarDeclarationParserRuleCall_0_0() { return cVarDeclarationVarDeclarationParserRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=VarType
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//VarType
		public RuleCall getTypeVarTypeParserRuleCall_2_0() { return cTypeVarTypeParserRuleCall_2_0; }
	}
	public class VarDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.VarDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarsVarNameParserRuleCall_0_0 = (RuleCall)cVarsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cVarsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cVarsVarNameParserRuleCall_1_1_0 = (RuleCall)cVarsAssignment_1_1.eContents().get(0);
		
		//VarDeclaration:
		//	vars+=VarName (',' vars+=VarName)*;
		@Override public ParserRule getRule() { return rule; }
		
		//vars+=VarName (',' vars+=VarName)*
		public Group getGroup() { return cGroup; }
		
		//vars+=VarName
		public Assignment getVarsAssignment_0() { return cVarsAssignment_0; }
		
		//VarName
		public RuleCall getVarsVarNameParserRuleCall_0_0() { return cVarsVarNameParserRuleCall_0_0; }
		
		//(',' vars+=VarName)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//vars+=VarName
		public Assignment getVarsAssignment_1_1() { return cVarsAssignment_1_1; }
		
		//VarName
		public RuleCall getVarsVarNameParserRuleCall_1_1_0() { return cVarsVarNameParserRuleCall_1_1_0; }
	}
	public class DeclaredVarListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.DeclaredVarList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cVarsVarNameCrossReference_0_0 = (CrossReference)cVarsAssignment_0.eContents().get(0);
		private final RuleCall cVarsVarNameIDTerminalRuleCall_0_0_1 = (RuleCall)cVarsVarNameCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cVarsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final CrossReference cVarsVarNameCrossReference_1_1_0 = (CrossReference)cVarsAssignment_1_1.eContents().get(0);
		private final RuleCall cVarsVarNameIDTerminalRuleCall_1_1_0_1 = (RuleCall)cVarsVarNameCrossReference_1_1_0.eContents().get(1);
		
		//DeclaredVarList:
		//	vars+=[VarName] (',' vars+=[VarName])*;
		@Override public ParserRule getRule() { return rule; }
		
		//vars+=[VarName] (',' vars+=[VarName])*
		public Group getGroup() { return cGroup; }
		
		//vars+=[VarName]
		public Assignment getVarsAssignment_0() { return cVarsAssignment_0; }
		
		//[VarName]
		public CrossReference getVarsVarNameCrossReference_0_0() { return cVarsVarNameCrossReference_0_0; }
		
		//ID
		public RuleCall getVarsVarNameIDTerminalRuleCall_0_0_1() { return cVarsVarNameIDTerminalRuleCall_0_0_1; }
		
		//(',' vars+=[VarName])*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//vars+=[VarName]
		public Assignment getVarsAssignment_1_1() { return cVarsAssignment_1_1; }
		
		//[VarName]
		public CrossReference getVarsVarNameCrossReference_1_1_0() { return cVarsVarNameCrossReference_1_1_0; }
		
		//ID
		public RuleCall getVarsVarNameIDTerminalRuleCall_1_1_0_1() { return cVarsVarNameIDTerminalRuleCall_1_1_0_1; }
	}
	public class VarNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.VarName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//VarName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class VarTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.VarType");
		private final Assignment cTypeNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cTypeNameAlternatives_0 = (Alternatives)cTypeNameAssignment.eContents().get(0);
		private final Keyword cTypeNameRealKeyword_0_0 = (Keyword)cTypeNameAlternatives_0.eContents().get(0);
		private final Keyword cTypeNameInteiroKeyword_0_1 = (Keyword)cTypeNameAlternatives_0.eContents().get(1);
		private final Keyword cTypeNameCaractereKeyword_0_2 = (Keyword)cTypeNameAlternatives_0.eContents().get(2);
		private final Keyword cTypeNameCaracterKeyword_0_3 = (Keyword)cTypeNameAlternatives_0.eContents().get(3);
		private final Keyword cTypeNameLogicoKeyword_0_4 = (Keyword)cTypeNameAlternatives_0.eContents().get(4);
		
		//VarType:
		//	typeName=('real' | 'inteiro' | 'caractere' | 'caracter' | 'logico');
		@Override public ParserRule getRule() { return rule; }
		
		//typeName=('real' | 'inteiro' | 'caractere' | 'caracter' | 'logico')
		public Assignment getTypeNameAssignment() { return cTypeNameAssignment; }
		
		//('real' | 'inteiro' | 'caractere' | 'caracter' | 'logico')
		public Alternatives getTypeNameAlternatives_0() { return cTypeNameAlternatives_0; }
		
		//'real'
		public Keyword getTypeNameRealKeyword_0_0() { return cTypeNameRealKeyword_0_0; }
		
		//'inteiro'
		public Keyword getTypeNameInteiroKeyword_0_1() { return cTypeNameInteiroKeyword_0_1; }
		
		//'caractere'
		public Keyword getTypeNameCaractereKeyword_0_2() { return cTypeNameCaractereKeyword_0_2; }
		
		//'caracter'
		public Keyword getTypeNameCaracterKeyword_0_3() { return cTypeNameCaracterKeyword_0_3; }
		
		//'logico'
		public Keyword getTypeNameLogicoKeyword_0_4() { return cTypeNameLogicoKeyword_0_4; }
	}
	public class SubprogramsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Subprograms");
		private final Assignment cBlockSubProgramsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cBlockSubProgramsBlockSubProgramsParserRuleCall_0 = (RuleCall)cBlockSubProgramsAssignment.eContents().get(0);
		
		//Subprograms:
		//	blockSubPrograms+=BlockSubPrograms+;
		@Override public ParserRule getRule() { return rule; }
		
		//blockSubPrograms+=BlockSubPrograms+
		public Assignment getBlockSubProgramsAssignment() { return cBlockSubProgramsAssignment; }
		
		//BlockSubPrograms
		public RuleCall getBlockSubProgramsBlockSubProgramsParserRuleCall_0() { return cBlockSubProgramsBlockSubProgramsParserRuleCall_0; }
	}
	public class BlockSubProgramsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.BlockSubPrograms");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBlockFunctionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBlockProcedureParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//BlockSubPrograms:
		//	BlockFunction | BlockProcedure;
		@Override public ParserRule getRule() { return rule; }
		
		//BlockFunction | BlockProcedure
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BlockFunction
		public RuleCall getBlockFunctionParserRuleCall_0() { return cBlockFunctionParserRuleCall_0; }
		
		//BlockProcedure
		public RuleCall getBlockProcedureParserRuleCall_1() { return cBlockProcedureParserRuleCall_1; }
	}
	public class ProcedureNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.ProcedureName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//ProcedureName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class FunctionNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.FunctionName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//FunctionName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class BlockFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.BlockFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFuncaoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFunctionNameFunctionNameParserRuleCall_1_0 = (RuleCall)cFunctionNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cParamsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParamsSubprogramParamDeclarationParserRuleCall_3_0 = (RuleCall)cParamsAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cColonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cReturnTypeAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cReturnTypeVarTypeParserRuleCall_6_0 = (RuleCall)cReturnTypeAssignment_6.eContents().get(0);
		private final Assignment cDeclarationsAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cDeclarationsDeclarationsBlockParserRuleCall_7_0 = (RuleCall)cDeclarationsAssignment_7.eContents().get(0);
		private final Keyword cInicioKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cCommandsAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cCommandsAbstractCommandParserRuleCall_9_0 = (RuleCall)cCommandsAssignment_9.eContents().get(0);
		private final Keyword cFimfuncaoKeyword_10 = (Keyword)cGroup.eContents().get(10);
		
		//BlockFunction:
		//	'funcao' functionName=FunctionName '(' params=SubprogramParamDeclaration? ')' ':' returnType=VarType
		//	declarations=DeclarationsBlock?
		//	'inicio'
		//	commands+=AbstractCommand+
		//	'fimfuncao';
		@Override public ParserRule getRule() { return rule; }
		
		//'funcao' functionName=FunctionName '(' params=SubprogramParamDeclaration? ')' ':' returnType=VarType
		//declarations=DeclarationsBlock? 'inicio' commands+=AbstractCommand+ 'fimfuncao'
		public Group getGroup() { return cGroup; }
		
		//'funcao'
		public Keyword getFuncaoKeyword_0() { return cFuncaoKeyword_0; }
		
		//functionName=FunctionName
		public Assignment getFunctionNameAssignment_1() { return cFunctionNameAssignment_1; }
		
		//FunctionName
		public RuleCall getFunctionNameFunctionNameParserRuleCall_1_0() { return cFunctionNameFunctionNameParserRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//params=SubprogramParamDeclaration?
		public Assignment getParamsAssignment_3() { return cParamsAssignment_3; }
		
		//SubprogramParamDeclaration
		public RuleCall getParamsSubprogramParamDeclarationParserRuleCall_3_0() { return cParamsSubprogramParamDeclarationParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//':'
		public Keyword getColonKeyword_5() { return cColonKeyword_5; }
		
		//returnType=VarType
		public Assignment getReturnTypeAssignment_6() { return cReturnTypeAssignment_6; }
		
		//VarType
		public RuleCall getReturnTypeVarTypeParserRuleCall_6_0() { return cReturnTypeVarTypeParserRuleCall_6_0; }
		
		//declarations=DeclarationsBlock?
		public Assignment getDeclarationsAssignment_7() { return cDeclarationsAssignment_7; }
		
		//DeclarationsBlock
		public RuleCall getDeclarationsDeclarationsBlockParserRuleCall_7_0() { return cDeclarationsDeclarationsBlockParserRuleCall_7_0; }
		
		//'inicio'
		public Keyword getInicioKeyword_8() { return cInicioKeyword_8; }
		
		//commands+=AbstractCommand+
		public Assignment getCommandsAssignment_9() { return cCommandsAssignment_9; }
		
		//AbstractCommand
		public RuleCall getCommandsAbstractCommandParserRuleCall_9_0() { return cCommandsAbstractCommandParserRuleCall_9_0; }
		
		//'fimfuncao'
		public Keyword getFimfuncaoKeyword_10() { return cFimfuncaoKeyword_10; }
	}
	public class BlockProcedureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.BlockProcedure");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cProcedimentoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cProcedureNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cProcedureNameProcedureNameParserRuleCall_1_0 = (RuleCall)cProcedureNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cParamsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParamsSubprogramParamDeclarationParserRuleCall_3_0 = (RuleCall)cParamsAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cDeclarationsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cDeclarationsDeclarationsBlockParserRuleCall_5_0 = (RuleCall)cDeclarationsAssignment_5.eContents().get(0);
		private final Keyword cInicioKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cCommandsAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cCommandsAbstractCommandParserRuleCall_7_0 = (RuleCall)cCommandsAssignment_7.eContents().get(0);
		private final Keyword cFimprocedimentoKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//BlockProcedure:
		//	'procedimento' procedureName=ProcedureName '(' params=SubprogramParamDeclaration? ')'
		//	declarations=DeclarationsBlock?
		//	'inicio'
		//	commands+=AbstractCommand+
		//	'fimprocedimento';
		@Override public ParserRule getRule() { return rule; }
		
		//'procedimento' procedureName=ProcedureName '(' params=SubprogramParamDeclaration? ')' declarations=DeclarationsBlock?
		//'inicio' commands+=AbstractCommand+ 'fimprocedimento'
		public Group getGroup() { return cGroup; }
		
		//'procedimento'
		public Keyword getProcedimentoKeyword_0() { return cProcedimentoKeyword_0; }
		
		//procedureName=ProcedureName
		public Assignment getProcedureNameAssignment_1() { return cProcedureNameAssignment_1; }
		
		//ProcedureName
		public RuleCall getProcedureNameProcedureNameParserRuleCall_1_0() { return cProcedureNameProcedureNameParserRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//params=SubprogramParamDeclaration?
		public Assignment getParamsAssignment_3() { return cParamsAssignment_3; }
		
		//SubprogramParamDeclaration
		public RuleCall getParamsSubprogramParamDeclarationParserRuleCall_3_0() { return cParamsSubprogramParamDeclarationParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//declarations=DeclarationsBlock?
		public Assignment getDeclarationsAssignment_5() { return cDeclarationsAssignment_5; }
		
		//DeclarationsBlock
		public RuleCall getDeclarationsDeclarationsBlockParserRuleCall_5_0() { return cDeclarationsDeclarationsBlockParserRuleCall_5_0; }
		
		//'inicio'
		public Keyword getInicioKeyword_6() { return cInicioKeyword_6; }
		
		//commands+=AbstractCommand+
		public Assignment getCommandsAssignment_7() { return cCommandsAssignment_7; }
		
		//AbstractCommand
		public RuleCall getCommandsAbstractCommandParserRuleCall_7_0() { return cCommandsAbstractCommandParserRuleCall_7_0; }
		
		//'fimprocedimento'
		public Keyword getFimprocedimentoKeyword_8() { return cFimprocedimentoKeyword_8; }
	}
	public class SubprogramParamDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.SubprogramParamDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cParamListAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cParamListVariableParserRuleCall_0_0 = (RuleCall)cParamListAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cSemicolonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cParamListAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cParamListVariableParserRuleCall_1_1_0 = (RuleCall)cParamListAssignment_1_1.eContents().get(0);
		
		//SubprogramParamDeclaration:
		//	paramList+=Variable (';' paramList+=Variable)*;
		@Override public ParserRule getRule() { return rule; }
		
		//paramList+=Variable (';' paramList+=Variable)*
		public Group getGroup() { return cGroup; }
		
		//paramList+=Variable
		public Assignment getParamListAssignment_0() { return cParamListAssignment_0; }
		
		//Variable
		public RuleCall getParamListVariableParserRuleCall_0_0() { return cParamListVariableParserRuleCall_0_0; }
		
		//(';' paramList+=Variable)*
		public Group getGroup_1() { return cGroup_1; }
		
		//';'
		public Keyword getSemicolonKeyword_1_0() { return cSemicolonKeyword_1_0; }
		
		//paramList+=Variable
		public Assignment getParamListAssignment_1_1() { return cParamListAssignment_1_1; }
		
		//Variable
		public RuleCall getParamListVariableParserRuleCall_1_1_0() { return cParamListVariableParserRuleCall_1_1_0; }
	}
	public class BlockCommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.BlockCommand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInicioKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cCommandsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommandsAbstractCommandParserRuleCall_1_0 = (RuleCall)cCommandsAssignment_1.eContents().get(0);
		private final Keyword cFimalgoritmoKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//BlockCommand:
		//	'inicio'
		//	commands+=AbstractCommand+
		//	'fimalgoritmo';
		@Override public ParserRule getRule() { return rule; }
		
		//'inicio' commands+=AbstractCommand+ 'fimalgoritmo'
		public Group getGroup() { return cGroup; }
		
		//'inicio'
		public Keyword getInicioKeyword_0() { return cInicioKeyword_0; }
		
		//commands+=AbstractCommand+
		public Assignment getCommandsAssignment_1() { return cCommandsAssignment_1; }
		
		//AbstractCommand
		public RuleCall getCommandsAbstractCommandParserRuleCall_1_0() { return cCommandsAbstractCommandParserRuleCall_1_0; }
		
		//'fimalgoritmo'
		public Keyword getFimalgoritmoKeyword_2() { return cFimalgoritmoKeyword_2; }
	}
	public class AbstractCommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.AbstractCommand");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cReadCommandParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cEND_COMMANDParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cWriteCommandParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cEND_COMMANDParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cExpressionParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final RuleCall cEND_COMMANDParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final RuleCall cIfStatementParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cSwitchCaseStatementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cForStatementParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cRepeatStatementParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cWhileStatementParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final Group cGroup_8 = (Group)cAlternatives.eContents().get(8);
		private final RuleCall cBreakStatementParserRuleCall_8_0 = (RuleCall)cGroup_8.eContents().get(0);
		private final RuleCall cEND_COMMANDParserRuleCall_8_1 = (RuleCall)cGroup_8.eContents().get(1);
		private final Group cGroup_9 = (Group)cAlternatives.eContents().get(9);
		private final RuleCall cReturnStatementParserRuleCall_9_0 = (RuleCall)cGroup_9.eContents().get(0);
		private final RuleCall cEND_COMMANDParserRuleCall_9_1 = (RuleCall)cGroup_9.eContents().get(1);
		
		//AbstractCommand:
		//	ReadCommand END_COMMAND
		//	| WriteCommand END_COMMAND
		//	| Expression END_COMMAND
		//	| IfStatement
		//	| SwitchCaseStatement
		//	| ForStatement
		//	| RepeatStatement
		//	| WhileStatement
		//	| BreakStatement END_COMMAND
		//	| ReturnStatement END_COMMAND;
		@Override public ParserRule getRule() { return rule; }
		
		//ReadCommand END_COMMAND | WriteCommand END_COMMAND | Expression END_COMMAND | IfStatement | SwitchCaseStatement |
		//ForStatement | RepeatStatement | WhileStatement | BreakStatement END_COMMAND | ReturnStatement END_COMMAND
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ReadCommand END_COMMAND
		public Group getGroup_0() { return cGroup_0; }
		
		//ReadCommand
		public RuleCall getReadCommandParserRuleCall_0_0() { return cReadCommandParserRuleCall_0_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDParserRuleCall_0_1() { return cEND_COMMANDParserRuleCall_0_1; }
		
		//WriteCommand END_COMMAND
		public Group getGroup_1() { return cGroup_1; }
		
		//WriteCommand
		public RuleCall getWriteCommandParserRuleCall_1_0() { return cWriteCommandParserRuleCall_1_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDParserRuleCall_1_1() { return cEND_COMMANDParserRuleCall_1_1; }
		
		//Expression END_COMMAND
		public Group getGroup_2() { return cGroup_2; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_2_0() { return cExpressionParserRuleCall_2_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDParserRuleCall_2_1() { return cEND_COMMANDParserRuleCall_2_1; }
		
		//IfStatement
		public RuleCall getIfStatementParserRuleCall_3() { return cIfStatementParserRuleCall_3; }
		
		//SwitchCaseStatement
		public RuleCall getSwitchCaseStatementParserRuleCall_4() { return cSwitchCaseStatementParserRuleCall_4; }
		
		//ForStatement
		public RuleCall getForStatementParserRuleCall_5() { return cForStatementParserRuleCall_5; }
		
		//RepeatStatement
		public RuleCall getRepeatStatementParserRuleCall_6() { return cRepeatStatementParserRuleCall_6; }
		
		//WhileStatement
		public RuleCall getWhileStatementParserRuleCall_7() { return cWhileStatementParserRuleCall_7; }
		
		//BreakStatement END_COMMAND
		public Group getGroup_8() { return cGroup_8; }
		
		//BreakStatement
		public RuleCall getBreakStatementParserRuleCall_8_0() { return cBreakStatementParserRuleCall_8_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDParserRuleCall_8_1() { return cEND_COMMANDParserRuleCall_8_1; }
		
		//ReturnStatement END_COMMAND
		public Group getGroup_9() { return cGroup_9; }
		
		//ReturnStatement
		public RuleCall getReturnStatementParserRuleCall_9_0() { return cReturnStatementParserRuleCall_9_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDParserRuleCall_9_1() { return cEND_COMMANDParserRuleCall_9_1; }
	}
	public class BreakStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.BreakStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBreakStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cInterrompaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//BreakStatement:
		//	{BreakStatement} 'interrompa';
		@Override public ParserRule getRule() { return rule; }
		
		//{BreakStatement} 'interrompa'
		public Group getGroup() { return cGroup; }
		
		//{BreakStatement}
		public Action getBreakStatementAction_0() { return cBreakStatementAction_0; }
		
		//'interrompa'
		public Keyword getInterrompaKeyword_1() { return cInterrompaKeyword_1; }
	}
	public class ReturnStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.ReturnStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cReturnStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cRetorneKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprExpressionParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//ReturnStatement:
		//	{ReturnStatement} 'retorne' expr=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//{ReturnStatement} 'retorne' expr=Expression
		public Group getGroup() { return cGroup; }
		
		//{ReturnStatement}
		public Action getReturnStatementAction_0() { return cReturnStatementAction_0; }
		
		//'retorne'
		public Keyword getRetorneKeyword_1() { return cRetorneKeyword_1; }
		
		//expr=Expression
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }
		
		//Expression
		public RuleCall getExprExpressionParserRuleCall_2_0() { return cExprExpressionParserRuleCall_2_0; }
	}
	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Keyword cEntaoKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cCommandsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCommandsAbstractCommandParserRuleCall_3_0 = (RuleCall)cCommandsAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cSenaoKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cElseCommandsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cElseCommandsAbstractCommandParserRuleCall_4_1_0 = (RuleCall)cElseCommandsAssignment_4_1.eContents().get(0);
		private final Keyword cFimseKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//IfStatement:
		//	'se' expr=Expression 'entao'
		//	commands+=AbstractCommand+ ('senao' elseCommands+=AbstractCommand+)?
		//	'fimse';
		@Override public ParserRule getRule() { return rule; }
		
		//'se' expr=Expression 'entao' commands+=AbstractCommand+ ('senao' elseCommands+=AbstractCommand+)? 'fimse'
		public Group getGroup() { return cGroup; }
		
		//'se'
		public Keyword getSeKeyword_0() { return cSeKeyword_0; }
		
		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }
		
		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }
		
		//'entao'
		public Keyword getEntaoKeyword_2() { return cEntaoKeyword_2; }
		
		//commands+=AbstractCommand+
		public Assignment getCommandsAssignment_3() { return cCommandsAssignment_3; }
		
		//AbstractCommand
		public RuleCall getCommandsAbstractCommandParserRuleCall_3_0() { return cCommandsAbstractCommandParserRuleCall_3_0; }
		
		//('senao' elseCommands+=AbstractCommand+)?
		public Group getGroup_4() { return cGroup_4; }
		
		//'senao'
		public Keyword getSenaoKeyword_4_0() { return cSenaoKeyword_4_0; }
		
		//elseCommands+=AbstractCommand+
		public Assignment getElseCommandsAssignment_4_1() { return cElseCommandsAssignment_4_1; }
		
		//AbstractCommand
		public RuleCall getElseCommandsAbstractCommandParserRuleCall_4_1_0() { return cElseCommandsAbstractCommandParserRuleCall_4_1_0; }
		
		//'fimse'
		public Keyword getFimseKeyword_5() { return cFimseKeyword_5; }
	}
	public class SwitchCaseStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.SwitchCaseStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEscolhaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVariableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cVariableVarNameCrossReference_1_0 = (CrossReference)cVariableAssignment_1.eContents().get(0);
		private final RuleCall cVariableVarNameIDTerminalRuleCall_1_0_1 = (RuleCall)cVariableVarNameCrossReference_1_0.eContents().get(1);
		private final Assignment cCaseListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCaseListCaseListParserRuleCall_2_0 = (RuleCall)cCaseListAssignment_2.eContents().get(0);
		private final Assignment cOtherCaseAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOtherCaseOtherCaseParserRuleCall_3_0 = (RuleCall)cOtherCaseAssignment_3.eContents().get(0);
		private final Keyword cFimescolhaKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//SwitchCaseStatement:
		//	'escolha' variable=[VarName] caseList+=CaseList+
		//	otherCase=OtherCase?
		//	'fimescolha';
		@Override public ParserRule getRule() { return rule; }
		
		//'escolha' variable=[VarName] caseList+=CaseList+ otherCase=OtherCase? 'fimescolha'
		public Group getGroup() { return cGroup; }
		
		//'escolha'
		public Keyword getEscolhaKeyword_0() { return cEscolhaKeyword_0; }
		
		//variable=[VarName]
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }
		
		//[VarName]
		public CrossReference getVariableVarNameCrossReference_1_0() { return cVariableVarNameCrossReference_1_0; }
		
		//ID
		public RuleCall getVariableVarNameIDTerminalRuleCall_1_0_1() { return cVariableVarNameIDTerminalRuleCall_1_0_1; }
		
		//caseList+=CaseList+
		public Assignment getCaseListAssignment_2() { return cCaseListAssignment_2; }
		
		//CaseList
		public RuleCall getCaseListCaseListParserRuleCall_2_0() { return cCaseListCaseListParserRuleCall_2_0; }
		
		//otherCase=OtherCase?
		public Assignment getOtherCaseAssignment_3() { return cOtherCaseAssignment_3; }
		
		//OtherCase
		public RuleCall getOtherCaseOtherCaseParserRuleCall_3_0() { return cOtherCaseOtherCaseParserRuleCall_3_0; }
		
		//'fimescolha'
		public Keyword getFimescolhaKeyword_4() { return cFimescolhaKeyword_4; }
	}
	public class CaseListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.CaseList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCasoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cCommandsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCommandsAbstractCommandParserRuleCall_3_0 = (RuleCall)cCommandsAssignment_3.eContents().get(0);
		
		//CaseList:
		//	'caso' expr=Expression ':'
		//	commands+=AbstractCommand+;
		@Override public ParserRule getRule() { return rule; }
		
		//'caso' expr=Expression ':' commands+=AbstractCommand+
		public Group getGroup() { return cGroup; }
		
		//'caso'
		public Keyword getCasoKeyword_0() { return cCasoKeyword_0; }
		
		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }
		
		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//commands+=AbstractCommand+
		public Assignment getCommandsAssignment_3() { return cCommandsAssignment_3; }
		
		//AbstractCommand
		public RuleCall getCommandsAbstractCommandParserRuleCall_3_0() { return cCommandsAbstractCommandParserRuleCall_3_0; }
	}
	public class OtherCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.OtherCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cOutrocasoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOtherCaseCommandsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOtherCaseCommandsAbstractCommandParserRuleCall_2_0 = (RuleCall)cOtherCaseCommandsAssignment_2.eContents().get(0);
		
		//OtherCase:
		//	'outrocaso' ':'
		//	otherCaseCommands+=AbstractCommand+;
		@Override public ParserRule getRule() { return rule; }
		
		//'outrocaso' ':' otherCaseCommands+=AbstractCommand+
		public Group getGroup() { return cGroup; }
		
		//'outrocaso'
		public Keyword getOutrocasoKeyword_0() { return cOutrocasoKeyword_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//otherCaseCommands+=AbstractCommand+
		public Assignment getOtherCaseCommandsAssignment_2() { return cOtherCaseCommandsAssignment_2; }
		
		//AbstractCommand
		public RuleCall getOtherCaseCommandsAbstractCommandParserRuleCall_2_0() { return cOtherCaseCommandsAbstractCommandParserRuleCall_2_0; }
	}
	public class ForStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.ForStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cParaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cOperatorExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperatorExprExpressionParserRuleCall_1_0 = (RuleCall)cOperatorExprAssignment_1.eContents().get(0);
		private final Keyword cDeKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStartExprAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStartExprExpressionParserRuleCall_3_0 = (RuleCall)cStartExprAssignment_3.eContents().get(0);
		private final Keyword cAteKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cEndExprAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cEndExprExpressionParserRuleCall_5_0 = (RuleCall)cEndExprAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cPassoKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cStepExpeAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cStepExpeExpressionParserRuleCall_6_1_0 = (RuleCall)cStepExpeAssignment_6_1.eContents().get(0);
		private final Keyword cFacaKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cCommandsAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cCommandsAbstractCommandParserRuleCall_8_0 = (RuleCall)cCommandsAssignment_8.eContents().get(0);
		private final Keyword cFimparaKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//ForStatement:
		//	'para' operatorExpr=Expression 'de' startExpr=Expression 'ate' endExpr=Expression ('passo' stepExpe=Expression)?
		//	'faca'
		//	commands+=AbstractCommand+
		//	'fimpara';
		@Override public ParserRule getRule() { return rule; }
		
		//'para' operatorExpr=Expression 'de' startExpr=Expression 'ate' endExpr=Expression ('passo' stepExpe=Expression)? 'faca'
		//commands+=AbstractCommand+ 'fimpara'
		public Group getGroup() { return cGroup; }
		
		//'para'
		public Keyword getParaKeyword_0() { return cParaKeyword_0; }
		
		//operatorExpr=Expression
		public Assignment getOperatorExprAssignment_1() { return cOperatorExprAssignment_1; }
		
		//Expression
		public RuleCall getOperatorExprExpressionParserRuleCall_1_0() { return cOperatorExprExpressionParserRuleCall_1_0; }
		
		//'de'
		public Keyword getDeKeyword_2() { return cDeKeyword_2; }
		
		//startExpr=Expression
		public Assignment getStartExprAssignment_3() { return cStartExprAssignment_3; }
		
		//Expression
		public RuleCall getStartExprExpressionParserRuleCall_3_0() { return cStartExprExpressionParserRuleCall_3_0; }
		
		//'ate'
		public Keyword getAteKeyword_4() { return cAteKeyword_4; }
		
		//endExpr=Expression
		public Assignment getEndExprAssignment_5() { return cEndExprAssignment_5; }
		
		//Expression
		public RuleCall getEndExprExpressionParserRuleCall_5_0() { return cEndExprExpressionParserRuleCall_5_0; }
		
		//('passo' stepExpe=Expression)?
		public Group getGroup_6() { return cGroup_6; }
		
		//'passo'
		public Keyword getPassoKeyword_6_0() { return cPassoKeyword_6_0; }
		
		//stepExpe=Expression
		public Assignment getStepExpeAssignment_6_1() { return cStepExpeAssignment_6_1; }
		
		//Expression
		public RuleCall getStepExpeExpressionParserRuleCall_6_1_0() { return cStepExpeExpressionParserRuleCall_6_1_0; }
		
		//'faca'
		public Keyword getFacaKeyword_7() { return cFacaKeyword_7; }
		
		//commands+=AbstractCommand+
		public Assignment getCommandsAssignment_8() { return cCommandsAssignment_8; }
		
		//AbstractCommand
		public RuleCall getCommandsAbstractCommandParserRuleCall_8_0() { return cCommandsAbstractCommandParserRuleCall_8_0; }
		
		//'fimpara'
		public Keyword getFimparaKeyword_9() { return cFimparaKeyword_9; }
	}
	public class WhileStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.WhileStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnquantoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cWhileExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cWhileExprExpressionParserRuleCall_1_0 = (RuleCall)cWhileExprAssignment_1.eContents().get(0);
		private final Keyword cFacaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cCommandsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCommandsAbstractCommandParserRuleCall_3_0 = (RuleCall)cCommandsAssignment_3.eContents().get(0);
		private final Keyword cFimenquantoKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//WhileStatement:
		//	'enquanto' whileExpr=Expression 'faca'
		//	commands+=AbstractCommand+
		//	'fimenquanto';
		@Override public ParserRule getRule() { return rule; }
		
		//'enquanto' whileExpr=Expression 'faca' commands+=AbstractCommand+ 'fimenquanto'
		public Group getGroup() { return cGroup; }
		
		//'enquanto'
		public Keyword getEnquantoKeyword_0() { return cEnquantoKeyword_0; }
		
		//whileExpr=Expression
		public Assignment getWhileExprAssignment_1() { return cWhileExprAssignment_1; }
		
		//Expression
		public RuleCall getWhileExprExpressionParserRuleCall_1_0() { return cWhileExprExpressionParserRuleCall_1_0; }
		
		//'faca'
		public Keyword getFacaKeyword_2() { return cFacaKeyword_2; }
		
		//commands+=AbstractCommand+
		public Assignment getCommandsAssignment_3() { return cCommandsAssignment_3; }
		
		//AbstractCommand
		public RuleCall getCommandsAbstractCommandParserRuleCall_3_0() { return cCommandsAbstractCommandParserRuleCall_3_0; }
		
		//'fimenquanto'
		public Keyword getFimenquantoKeyword_4() { return cFimenquantoKeyword_4; }
	}
	public class RepeatStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.RepeatStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRepitaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cCommandsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommandsAbstractCommandParserRuleCall_1_0 = (RuleCall)cCommandsAssignment_1.eContents().get(0);
		private final Keyword cAteKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cUntilExprAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cUntilExprExpressionParserRuleCall_3_0 = (RuleCall)cUntilExprAssignment_3.eContents().get(0);
		private final RuleCall cEND_COMMANDParserRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//RepeatStatement:
		//	'repita'
		//	commands+=AbstractCommand+
		//	'ate' untilExpr=Expression END_COMMAND;
		@Override public ParserRule getRule() { return rule; }
		
		//'repita' commands+=AbstractCommand+ 'ate' untilExpr=Expression END_COMMAND
		public Group getGroup() { return cGroup; }
		
		//'repita'
		public Keyword getRepitaKeyword_0() { return cRepitaKeyword_0; }
		
		//commands+=AbstractCommand+
		public Assignment getCommandsAssignment_1() { return cCommandsAssignment_1; }
		
		//AbstractCommand
		public RuleCall getCommandsAbstractCommandParserRuleCall_1_0() { return cCommandsAbstractCommandParserRuleCall_1_0; }
		
		//'ate'
		public Keyword getAteKeyword_2() { return cAteKeyword_2; }
		
		//untilExpr=Expression
		public Assignment getUntilExprAssignment_3() { return cUntilExprAssignment_3; }
		
		//Expression
		public RuleCall getUntilExprExpressionParserRuleCall_3_0() { return cUntilExprExpressionParserRuleCall_3_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDParserRuleCall_4() { return cEND_COMMANDParserRuleCall_4; }
	}
	public class SubprogramParamElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.SubprogramParam");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionExpressionParserRuleCall_0_0 = (RuleCall)cExpressionAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cExpressionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_1_0 = (RuleCall)cExpressionAssignment_1_1.eContents().get(0);
		
		//SubprogramParam:
		//	expression+=Expression (',' expression+=Expression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//expression+=Expression (',' expression+=Expression)*
		public Group getGroup() { return cGroup; }
		
		//expression+=Expression
		public Assignment getExpressionAssignment_0() { return cExpressionAssignment_0; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_0_0() { return cExpressionExpressionParserRuleCall_0_0; }
		
		//(',' expression+=Expression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//expression+=Expression
		public Assignment getExpressionAssignment_1_1() { return cExpressionAssignment_1_1; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_1_0() { return cExpressionExpressionParserRuleCall_1_1_0; }
	}
	public class ReadCommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.ReadCommand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeiaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParamListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParamListDeclaredVarListParserRuleCall_2_0 = (RuleCall)cParamListAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ReadCommand:
		//	'leia' '(' paramList=DeclaredVarList ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'leia' '(' paramList=DeclaredVarList ')'
		public Group getGroup() { return cGroup; }
		
		//'leia'
		public Keyword getLeiaKeyword_0() { return cLeiaKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//paramList=DeclaredVarList
		public Assignment getParamListAssignment_2() { return cParamListAssignment_2; }
		
		//DeclaredVarList
		public RuleCall getParamListDeclaredVarListParserRuleCall_2_0() { return cParamListDeclaredVarListParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class WriteCommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.WriteCommand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cWriteCommandAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cWriteCommandAlternatives_0_0 = (Alternatives)cWriteCommandAssignment_0.eContents().get(0);
		private final Keyword cWriteCommandEscrevaKeyword_0_0_0 = (Keyword)cWriteCommandAlternatives_0_0.eContents().get(0);
		private final Keyword cWriteCommandEscrevalKeyword_0_0_1 = (Keyword)cWriteCommandAlternatives_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cWriteParamAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cWriteParamWriteParamParserRuleCall_2_0 = (RuleCall)cWriteParamAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//WriteCommand:
		//	writeCommand=('escreva' | 'escreval') '(' writeParam=WriteParam ')';
		@Override public ParserRule getRule() { return rule; }
		
		//writeCommand=('escreva' | 'escreval') '(' writeParam=WriteParam ')'
		public Group getGroup() { return cGroup; }
		
		//writeCommand=('escreva' | 'escreval')
		public Assignment getWriteCommandAssignment_0() { return cWriteCommandAssignment_0; }
		
		//('escreva' | 'escreval')
		public Alternatives getWriteCommandAlternatives_0_0() { return cWriteCommandAlternatives_0_0; }
		
		//'escreva'
		public Keyword getWriteCommandEscrevaKeyword_0_0_0() { return cWriteCommandEscrevaKeyword_0_0_0; }
		
		//'escreval'
		public Keyword getWriteCommandEscrevalKeyword_0_0_1() { return cWriteCommandEscrevalKeyword_0_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//writeParam=WriteParam
		public Assignment getWriteParamAssignment_2() { return cWriteParamAssignment_2; }
		
		//WriteParam
		public RuleCall getWriteParamWriteParamParserRuleCall_2_0() { return cWriteParamWriteParamParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class WriteParamElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.WriteParam");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cParamsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cParamsSubprogramParamParserRuleCall_0_0 = (RuleCall)cParamsAssignment_0.eContents().get(0);
		private final Assignment cPrecisionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPrecisionOptDecimalPrecisionParserRuleCall_1_0 = (RuleCall)cPrecisionAssignment_1.eContents().get(0);
		
		//WriteParam:
		//	params=SubprogramParam precision=OptDecimalPrecision?;
		@Override public ParserRule getRule() { return rule; }
		
		//params=SubprogramParam precision=OptDecimalPrecision?
		public Group getGroup() { return cGroup; }
		
		//params=SubprogramParam
		public Assignment getParamsAssignment_0() { return cParamsAssignment_0; }
		
		//SubprogramParam
		public RuleCall getParamsSubprogramParamParserRuleCall_0_0() { return cParamsSubprogramParamParserRuleCall_0_0; }
		
		//precision=OptDecimalPrecision?
		public Assignment getPrecisionAssignment_1() { return cPrecisionAssignment_1; }
		
		//OptDecimalPrecision
		public RuleCall getPrecisionOptDecimalPrecisionParserRuleCall_1_0() { return cPrecisionOptDecimalPrecisionParserRuleCall_1_0; }
	}
	public class OptDecimalPrecisionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.OptDecimalPrecision");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFirstPrecisionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFirstPrecisionINTTerminalRuleCall_1_0 = (RuleCall)cFirstPrecisionAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cSecondPrecisionAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cSecondPrecisionINTTerminalRuleCall_2_1_0 = (RuleCall)cSecondPrecisionAssignment_2_1.eContents().get(0);
		
		//OptDecimalPrecision:
		//	':' firstPrecision=INT (':' secondPrecision=INT)?;
		@Override public ParserRule getRule() { return rule; }
		
		//':' firstPrecision=INT (':' secondPrecision=INT)?
		public Group getGroup() { return cGroup; }
		
		//':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//firstPrecision=INT
		public Assignment getFirstPrecisionAssignment_1() { return cFirstPrecisionAssignment_1; }
		
		//INT
		public RuleCall getFirstPrecisionINTTerminalRuleCall_1_0() { return cFirstPrecisionINTTerminalRuleCall_1_0; }
		
		//(':' secondPrecision=INT)?
		public Group getGroup_2() { return cGroup_2; }
		
		//':'
		public Keyword getColonKeyword_2_0() { return cColonKeyword_2_0; }
		
		//secondPrecision=INT
		public Assignment getSecondPrecisionAssignment_2_1() { return cSecondPrecisionAssignment_2_1; }
		
		//INT
		public RuleCall getSecondPrecisionINTTerminalRuleCall_2_1_0() { return cSecondPrecisionINTTerminalRuleCall_2_1_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Expression");
		private final RuleCall cAssignmentParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression:
		//	Assignment;
		@Override public ParserRule getRule() { return rule; }
		
		//Assignment
		public RuleCall getAssignmentParserRuleCall() { return cAssignmentParserRuleCall; }
	}
	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cBinaryOperationLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOpAssignmentOperatorParserRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightAssignmentParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Assignment Expression:
		//	OrExpression (=> ({BinaryOperation.left=current} op=AssignmentOperator) right=Assignment)*
		@Override public ParserRule getRule() { return rule; }
		
		//OrExpression (=> ({BinaryOperation.left=current} op=AssignmentOperator) right=Assignment)*
		public Group getGroup() { return cGroup; }
		
		//OrExpression
		public RuleCall getOrExpressionParserRuleCall_0() { return cOrExpressionParserRuleCall_0; }
		
		//(=> ({BinaryOperation.left=current} op=AssignmentOperator) right=Assignment)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({BinaryOperation.left=current} op=AssignmentOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({BinaryOperation.left=current} op=AssignmentOperator)
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{BinaryOperation.left=current}
		public Action getBinaryOperationLeftAction_1_0_0_0() { return cBinaryOperationLeftAction_1_0_0_0; }
		
		//op=AssignmentOperator
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//AssignmentOperator
		public RuleCall getOpAssignmentOperatorParserRuleCall_1_0_0_1_0() { return cOpAssignmentOperatorParserRuleCall_1_0_0_1_0; }
		
		//right=Assignment
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//Assignment
		public RuleCall getRightAssignmentParserRuleCall_1_1_0() { return cRightAssignmentParserRuleCall_1_1_0; }
	}
	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXorExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cBinaryOperationLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOpOrOperatorParserRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightXorExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//OrExpression Expression:
		//	XorExpression (=> ({BinaryOperation.left=current} op=OrOperator) right=XorExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//XorExpression (=> ({BinaryOperation.left=current} op=OrOperator) right=XorExpression)*
		public Group getGroup() { return cGroup; }
		
		//XorExpression
		public RuleCall getXorExpressionParserRuleCall_0() { return cXorExpressionParserRuleCall_0; }
		
		//(=> ({BinaryOperation.left=current} op=OrOperator) right=XorExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({BinaryOperation.left=current} op=OrOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({BinaryOperation.left=current} op=OrOperator)
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{BinaryOperation.left=current}
		public Action getBinaryOperationLeftAction_1_0_0_0() { return cBinaryOperationLeftAction_1_0_0_0; }
		
		//op=OrOperator
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//OrOperator
		public RuleCall getOpOrOperatorParserRuleCall_1_0_0_1_0() { return cOpOrOperatorParserRuleCall_1_0_0_1_0; }
		
		//right=XorExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//XorExpression
		public RuleCall getRightXorExpressionParserRuleCall_1_1_0() { return cRightXorExpressionParserRuleCall_1_1_0; }
	}
	public class XorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.XorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cBinaryOperationLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOpXorOperatorParserRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightAndExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//XorExpression Expression:
		//	AndExpression (=> ({BinaryOperation.left=current} op=XorOperator) right=AndExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//AndExpression (=> ({BinaryOperation.left=current} op=XorOperator) right=AndExpression)*
		public Group getGroup() { return cGroup; }
		
		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }
		
		//(=> ({BinaryOperation.left=current} op=XorOperator) right=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({BinaryOperation.left=current} op=XorOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({BinaryOperation.left=current} op=XorOperator)
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{BinaryOperation.left=current}
		public Action getBinaryOperationLeftAction_1_0_0_0() { return cBinaryOperationLeftAction_1_0_0_0; }
		
		//op=XorOperator
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//XorOperator
		public RuleCall getOpXorOperatorParserRuleCall_1_0_0_1_0() { return cOpXorOperatorParserRuleCall_1_0_0_1_0; }
		
		//right=AndExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//AndExpression
		public RuleCall getRightAndExpressionParserRuleCall_1_1_0() { return cRightAndExpressionParserRuleCall_1_1_0; }
	}
	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cBinaryOperationLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOpAndOperatorParserRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightComparisonParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//AndExpression Expression:
		//	Comparison (=> ({BinaryOperation.left=current} op=AndOperator) right=Comparison)*
		@Override public ParserRule getRule() { return rule; }
		
		//Comparison (=> ({BinaryOperation.left=current} op=AndOperator) right=Comparison)*
		public Group getGroup() { return cGroup; }
		
		//Comparison
		public RuleCall getComparisonParserRuleCall_0() { return cComparisonParserRuleCall_0; }
		
		//(=> ({BinaryOperation.left=current} op=AndOperator) right=Comparison)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({BinaryOperation.left=current} op=AndOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({BinaryOperation.left=current} op=AndOperator)
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{BinaryOperation.left=current}
		public Action getBinaryOperationLeftAction_1_0_0_0() { return cBinaryOperationLeftAction_1_0_0_0; }
		
		//op=AndOperator
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//AndOperator
		public RuleCall getOpAndOperatorParserRuleCall_1_0_0_1_0() { return cOpAndOperatorParserRuleCall_1_0_0_1_0; }
		
		//right=Comparison
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//Comparison
		public RuleCall getRightComparisonParserRuleCall_1_1_0() { return cRightComparisonParserRuleCall_1_1_0; }
	}
	public class ComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Comparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEquExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cBinaryOperationLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOpComparisonOperatorParserRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightEquExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Comparison Expression:
		//	EquExpression (=> ({BinaryOperation.left=current} op=ComparisonOperator) right=EquExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//EquExpression (=> ({BinaryOperation.left=current} op=ComparisonOperator) right=EquExpression)*
		public Group getGroup() { return cGroup; }
		
		//EquExpression
		public RuleCall getEquExpressionParserRuleCall_0() { return cEquExpressionParserRuleCall_0; }
		
		//(=> ({BinaryOperation.left=current} op=ComparisonOperator) right=EquExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({BinaryOperation.left=current} op=ComparisonOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({BinaryOperation.left=current} op=ComparisonOperator)
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{BinaryOperation.left=current}
		public Action getBinaryOperationLeftAction_1_0_0_0() { return cBinaryOperationLeftAction_1_0_0_0; }
		
		//op=ComparisonOperator
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//ComparisonOperator
		public RuleCall getOpComparisonOperatorParserRuleCall_1_0_0_1_0() { return cOpComparisonOperatorParserRuleCall_1_0_0_1_0; }
		
		//right=EquExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//EquExpression
		public RuleCall getRightEquExpressionParserRuleCall_1_1_0() { return cRightEquExpressionParserRuleCall_1_1_0; }
	}
	public class EquExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.EquExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAddExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cBinaryOperationLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOpEqualityOperatorParserRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightAddExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//EquExpression Expression:
		//	AddExpression (=> ({BinaryOperation.left=current} op=EqualityOperator) right=AddExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//AddExpression (=> ({BinaryOperation.left=current} op=EqualityOperator) right=AddExpression)*
		public Group getGroup() { return cGroup; }
		
		//AddExpression
		public RuleCall getAddExpressionParserRuleCall_0() { return cAddExpressionParserRuleCall_0; }
		
		//(=> ({BinaryOperation.left=current} op=EqualityOperator) right=AddExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({BinaryOperation.left=current} op=EqualityOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({BinaryOperation.left=current} op=EqualityOperator)
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{BinaryOperation.left=current}
		public Action getBinaryOperationLeftAction_1_0_0_0() { return cBinaryOperationLeftAction_1_0_0_0; }
		
		//op=EqualityOperator
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//EqualityOperator
		public RuleCall getOpEqualityOperatorParserRuleCall_1_0_0_1_0() { return cOpEqualityOperatorParserRuleCall_1_0_0_1_0; }
		
		//right=AddExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//AddExpression
		public RuleCall getRightAddExpressionParserRuleCall_1_1_0() { return cRightAddExpressionParserRuleCall_1_1_0; }
	}
	public class AddExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.AddExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicativeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cBinaryOperationLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOpAddOperatorParserRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightMultiplicativeExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//AddExpression Expression:
		//	MultiplicativeExpression (=> ({BinaryOperation.left=current} op=AddOperator) right=MultiplicativeExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//MultiplicativeExpression (=> ({BinaryOperation.left=current} op=AddOperator) right=MultiplicativeExpression)*
		public Group getGroup() { return cGroup; }
		
		//MultiplicativeExpression
		public RuleCall getMultiplicativeExpressionParserRuleCall_0() { return cMultiplicativeExpressionParserRuleCall_0; }
		
		//(=> ({BinaryOperation.left=current} op=AddOperator) right=MultiplicativeExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({BinaryOperation.left=current} op=AddOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({BinaryOperation.left=current} op=AddOperator)
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{BinaryOperation.left=current}
		public Action getBinaryOperationLeftAction_1_0_0_0() { return cBinaryOperationLeftAction_1_0_0_0; }
		
		//op=AddOperator
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//AddOperator
		public RuleCall getOpAddOperatorParserRuleCall_1_0_0_1_0() { return cOpAddOperatorParserRuleCall_1_0_0_1_0; }
		
		//right=MultiplicativeExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//MultiplicativeExpression
		public RuleCall getRightMultiplicativeExpressionParserRuleCall_1_1_0() { return cRightMultiplicativeExpressionParserRuleCall_1_1_0; }
	}
	public class MultiplicativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.MultiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPowerExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cBinaryOperationLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOpMultiplicativeOperatorParserRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightPowerExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//MultiplicativeExpression Expression:
		//	PowerExpression (=> ({BinaryOperation.left=current} op=MultiplicativeOperator) right=PowerExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//PowerExpression (=> ({BinaryOperation.left=current} op=MultiplicativeOperator) right=PowerExpression)*
		public Group getGroup() { return cGroup; }
		
		//PowerExpression
		public RuleCall getPowerExpressionParserRuleCall_0() { return cPowerExpressionParserRuleCall_0; }
		
		//(=> ({BinaryOperation.left=current} op=MultiplicativeOperator) right=PowerExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({BinaryOperation.left=current} op=MultiplicativeOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({BinaryOperation.left=current} op=MultiplicativeOperator)
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{BinaryOperation.left=current}
		public Action getBinaryOperationLeftAction_1_0_0_0() { return cBinaryOperationLeftAction_1_0_0_0; }
		
		//op=MultiplicativeOperator
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//MultiplicativeOperator
		public RuleCall getOpMultiplicativeOperatorParserRuleCall_1_0_0_1_0() { return cOpMultiplicativeOperatorParserRuleCall_1_0_0_1_0; }
		
		//right=PowerExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//PowerExpression
		public RuleCall getRightPowerExpressionParserRuleCall_1_1_0() { return cRightPowerExpressionParserRuleCall_1_1_0; }
	}
	public class PowerExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.PowerExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryOperationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cBinaryOperationLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOpPowerOperatorParserRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightUnaryOperationParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//PowerExpression Expression:
		//	UnaryOperation (=> ({BinaryOperation.left=current} op=PowerOperator) right=UnaryOperation)*
		@Override public ParserRule getRule() { return rule; }
		
		//UnaryOperation (=> ({BinaryOperation.left=current} op=PowerOperator) right=UnaryOperation)*
		public Group getGroup() { return cGroup; }
		
		//UnaryOperation
		public RuleCall getUnaryOperationParserRuleCall_0() { return cUnaryOperationParserRuleCall_0; }
		
		//(=> ({BinaryOperation.left=current} op=PowerOperator) right=UnaryOperation)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({BinaryOperation.left=current} op=PowerOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({BinaryOperation.left=current} op=PowerOperator)
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{BinaryOperation.left=current}
		public Action getBinaryOperationLeftAction_1_0_0_0() { return cBinaryOperationLeftAction_1_0_0_0; }
		
		//op=PowerOperator
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//PowerOperator
		public RuleCall getOpPowerOperatorParserRuleCall_1_0_0_1_0() { return cOpPowerOperatorParserRuleCall_1_0_0_1_0; }
		
		//right=UnaryOperation
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//UnaryOperation
		public RuleCall getRightUnaryOperationParserRuleCall_1_1_0() { return cRightUnaryOperationParserRuleCall_1_1_0; }
	}
	public class AssignmentOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.AssignmentOperator");
		private final Assignment cOpAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cOpLessThanSignHyphenMinusKeyword_0 = (Keyword)cOpAssignment.eContents().get(0);
		
		//AssignmentOperator Operator:
		//	op='<-'
		@Override public ParserRule getRule() { return rule; }
		
		//op='<-'
		public Assignment getOpAssignment() { return cOpAssignment; }
		
		//'<-'
		public Keyword getOpLessThanSignHyphenMinusKeyword_0() { return cOpLessThanSignHyphenMinusKeyword_0; }
	}
	public class OrOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.OrOperator");
		private final Assignment cOpAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cOpOUKeyword_0 = (Keyword)cOpAssignment.eContents().get(0);
		
		//OrOperator Operator:
		//	op='OU'
		@Override public ParserRule getRule() { return rule; }
		
		//op='OU'
		public Assignment getOpAssignment() { return cOpAssignment; }
		
		//'OU'
		public Keyword getOpOUKeyword_0() { return cOpOUKeyword_0; }
	}
	public class XorOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.XorOperator");
		private final Assignment cOpAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cOpXOUKeyword_0 = (Keyword)cOpAssignment.eContents().get(0);
		
		//XorOperator Operator:
		//	op='XOU'
		@Override public ParserRule getRule() { return rule; }
		
		//op='XOU'
		public Assignment getOpAssignment() { return cOpAssignment; }
		
		//'XOU'
		public Keyword getOpXOUKeyword_0() { return cOpXOUKeyword_0; }
	}
	public class AndOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.AndOperator");
		private final Assignment cOpAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cOpEKeyword_0 = (Keyword)cOpAssignment.eContents().get(0);
		
		//AndOperator Operator:
		//	op='E'
		@Override public ParserRule getRule() { return rule; }
		
		//op='E'
		public Assignment getOpAssignment() { return cOpAssignment; }
		
		//'E'
		public Keyword getOpEKeyword_0() { return cOpEKeyword_0; }
	}
	public class ComparisonOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.ComparisonOperator");
		private final Assignment cOpAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cOpAlternatives_0 = (Alternatives)cOpAssignment.eContents().get(0);
		private final Keyword cOpEqualsSignKeyword_0_0 = (Keyword)cOpAlternatives_0.eContents().get(0);
		private final Keyword cOpLessThanSignGreaterThanSignKeyword_0_1 = (Keyword)cOpAlternatives_0.eContents().get(1);
		
		//ComparisonOperator Operator:
		//	op=('=' | '<>')
		@Override public ParserRule getRule() { return rule; }
		
		//op=('=' | '<>')
		public Assignment getOpAssignment() { return cOpAssignment; }
		
		//('=' | '<>')
		public Alternatives getOpAlternatives_0() { return cOpAlternatives_0; }
		
		//'='
		public Keyword getOpEqualsSignKeyword_0_0() { return cOpEqualsSignKeyword_0_0; }
		
		//'<>'
		public Keyword getOpLessThanSignGreaterThanSignKeyword_0_1() { return cOpLessThanSignGreaterThanSignKeyword_0_1; }
	}
	public class EqualityOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.EqualityOperator");
		private final Assignment cOpAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cOpAlternatives_0 = (Alternatives)cOpAssignment.eContents().get(0);
		private final Keyword cOpLessThanSignKeyword_0_0 = (Keyword)cOpAlternatives_0.eContents().get(0);
		private final Keyword cOpGreaterThanSignKeyword_0_1 = (Keyword)cOpAlternatives_0.eContents().get(1);
		private final Keyword cOpLessThanSignEqualsSignKeyword_0_2 = (Keyword)cOpAlternatives_0.eContents().get(2);
		private final Keyword cOpGreaterThanSignEqualsSignKeyword_0_3 = (Keyword)cOpAlternatives_0.eContents().get(3);
		
		//EqualityOperator Operator:
		//	op=('<' | '>' | '<=' | '>=')
		@Override public ParserRule getRule() { return rule; }
		
		//op=('<' | '>' | '<=' | '>=')
		public Assignment getOpAssignment() { return cOpAssignment; }
		
		//('<' | '>' | '<=' | '>=')
		public Alternatives getOpAlternatives_0() { return cOpAlternatives_0; }
		
		//'<'
		public Keyword getOpLessThanSignKeyword_0_0() { return cOpLessThanSignKeyword_0_0; }
		
		//'>'
		public Keyword getOpGreaterThanSignKeyword_0_1() { return cOpGreaterThanSignKeyword_0_1; }
		
		//'<='
		public Keyword getOpLessThanSignEqualsSignKeyword_0_2() { return cOpLessThanSignEqualsSignKeyword_0_2; }
		
		//'>='
		public Keyword getOpGreaterThanSignEqualsSignKeyword_0_3() { return cOpGreaterThanSignEqualsSignKeyword_0_3; }
	}
	public class AddOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.AddOperator");
		private final Assignment cOpAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cOpAlternatives_0 = (Alternatives)cOpAssignment.eContents().get(0);
		private final Keyword cOpPlusSignKeyword_0_0 = (Keyword)cOpAlternatives_0.eContents().get(0);
		private final Keyword cOpHyphenMinusKeyword_0_1 = (Keyword)cOpAlternatives_0.eContents().get(1);
		
		//AddOperator Operator:
		//	op=('+' | '-')
		@Override public ParserRule getRule() { return rule; }
		
		//op=('+' | '-')
		public Assignment getOpAssignment() { return cOpAssignment; }
		
		//('+' | '-')
		public Alternatives getOpAlternatives_0() { return cOpAlternatives_0; }
		
		//'+'
		public Keyword getOpPlusSignKeyword_0_0() { return cOpPlusSignKeyword_0_0; }
		
		//'-'
		public Keyword getOpHyphenMinusKeyword_0_1() { return cOpHyphenMinusKeyword_0_1; }
	}
	public class MultiplicativeOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.MultiplicativeOperator");
		private final Assignment cOpAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cOpAlternatives_0 = (Alternatives)cOpAssignment.eContents().get(0);
		private final Keyword cOpAsteriskKeyword_0_0 = (Keyword)cOpAlternatives_0.eContents().get(0);
		private final Keyword cOpSolidusKeyword_0_1 = (Keyword)cOpAlternatives_0.eContents().get(1);
		private final Keyword cOpMODKeyword_0_2 = (Keyword)cOpAlternatives_0.eContents().get(2);
		private final Keyword cOpPercentSignKeyword_0_3 = (Keyword)cOpAlternatives_0.eContents().get(3);
		
		//MultiplicativeOperator Operator:
		//	op=('*' | '/' | 'MOD' | '%')
		@Override public ParserRule getRule() { return rule; }
		
		//op=('*' | '/' | 'MOD' | '%')
		public Assignment getOpAssignment() { return cOpAssignment; }
		
		//('*' | '/' | 'MOD' | '%')
		public Alternatives getOpAlternatives_0() { return cOpAlternatives_0; }
		
		//'*'
		public Keyword getOpAsteriskKeyword_0_0() { return cOpAsteriskKeyword_0_0; }
		
		//'/'
		public Keyword getOpSolidusKeyword_0_1() { return cOpSolidusKeyword_0_1; }
		
		//'MOD'
		public Keyword getOpMODKeyword_0_2() { return cOpMODKeyword_0_2; }
		
		//'%'
		public Keyword getOpPercentSignKeyword_0_3() { return cOpPercentSignKeyword_0_3; }
	}
	public class PowerOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.PowerOperator");
		private final Assignment cOpAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cOpCircumflexAccentKeyword_0 = (Keyword)cOpAssignment.eContents().get(0);
		
		//PowerOperator Operator:
		//	op='^'
		@Override public ParserRule getRule() { return rule; }
		
		//op='^'
		public Assignment getOpAssignment() { return cOpAssignment; }
		
		//'^'
		public Keyword getOpCircumflexAccentKeyword_0() { return cOpCircumflexAccentKeyword_0; }
	}
	public class NotOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.NotOperator");
		private final Assignment cOpAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cOpAlternatives_0 = (Alternatives)cOpAssignment.eContents().get(0);
		private final Keyword cOpNAOKeyword_0_0 = (Keyword)cOpAlternatives_0.eContents().get(0);
		private final Keyword cOpHyphenMinusKeyword_0_1 = (Keyword)cOpAlternatives_0.eContents().get(1);
		
		//NotOperator Operator:
		//	op=('NAO' | '-')
		@Override public ParserRule getRule() { return rule; }
		
		//op=('NAO' | '-')
		public Assignment getOpAssignment() { return cOpAssignment; }
		
		//('NAO' | '-')
		public Alternatives getOpAlternatives_0() { return cOpAlternatives_0; }
		
		//'NAO'
		public Keyword getOpNAOKeyword_0_0() { return cOpNAOKeyword_0_0; }
		
		//'-'
		public Keyword getOpHyphenMinusKeyword_0_1() { return cOpHyphenMinusKeyword_0_1; }
	}
	public class UnaryOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.UnaryOperation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cUnaryOperationAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cOpAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cOpNotOperatorParserRuleCall_0_1_0 = (RuleCall)cOpAssignment_0_1.eContents().get(0);
		private final Assignment cOperandAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cOperandUnaryOperationParserRuleCall_0_2_0 = (RuleCall)cOperandAssignment_0_2.eContents().get(0);
		private final RuleCall cPrimaryExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//UnaryOperation Expression:
		//	{UnaryOperation} op=NotOperator operand=UnaryOperation / * right associativity * /
		//	| PrimaryExpression
		@Override public ParserRule getRule() { return rule; }
		
		//{UnaryOperation} op=NotOperator operand=UnaryOperation / * right associativity * / | PrimaryExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{UnaryOperation} op=NotOperator operand=UnaryOperation
		public Group getGroup_0() { return cGroup_0; }
		
		//{UnaryOperation}
		public Action getUnaryOperationAction_0_0() { return cUnaryOperationAction_0_0; }
		
		//op=NotOperator
		public Assignment getOpAssignment_0_1() { return cOpAssignment_0_1; }
		
		//NotOperator
		public RuleCall getOpNotOperatorParserRuleCall_0_1_0() { return cOpNotOperatorParserRuleCall_0_1_0; }
		
		//operand=UnaryOperation
		public Assignment getOperandAssignment_0_2() { return cOperandAssignment_0_2; }
		
		//UnaryOperation
		public RuleCall getOperandUnaryOperationParserRuleCall_0_2_0() { return cOperandUnaryOperationParserRuleCall_0_2_0; }
		
		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_1() { return cPrimaryExpressionParserRuleCall_1; }
	}
	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPreDefinedFunctionCallParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cFunctionCallParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cDeclaredVarParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		
		//PrimaryExpression Expression:
		//	Literal
		//	| PreDefinedFunctionCall
		//	| FunctionCall
		//	| DeclaredVar
		//	| '(' Expression ')'
		@Override public ParserRule getRule() { return rule; }
		
		//Literal | PreDefinedFunctionCall | FunctionCall | DeclaredVar | '(' Expression ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Literal
		public RuleCall getLiteralParserRuleCall_0() { return cLiteralParserRuleCall_0; }
		
		//PreDefinedFunctionCall
		public RuleCall getPreDefinedFunctionCallParserRuleCall_1() { return cPreDefinedFunctionCallParserRuleCall_1; }
		
		//FunctionCall
		public RuleCall getFunctionCallParserRuleCall_2() { return cFunctionCallParserRuleCall_2; }
		
		//DeclaredVar
		public RuleCall getDeclaredVarParserRuleCall_3() { return cDeclaredVarParserRuleCall_3; }
		
		//'(' Expression ')'
		public Group getGroup_4() { return cGroup_4; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_4_0() { return cLeftParenthesisKeyword_4_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_4_1() { return cExpressionParserRuleCall_4_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4_2() { return cRightParenthesisKeyword_4_2; }
	}
	public class PreDefinedFunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.PreDefinedFunctionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPreDefFunctionNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPreDefFunctionNamePredefineFunctionsParserRuleCall_0_0 = (RuleCall)cPreDefFunctionNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParamAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParamSubprogramParamParserRuleCall_2_0 = (RuleCall)cParamAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//PreDefinedFunctionCall Expression:
		//	preDefFunctionName=PredefineFunctions '(' param=SubprogramParam ')'
		@Override public ParserRule getRule() { return rule; }
		
		//preDefFunctionName=PredefineFunctions '(' param=SubprogramParam ')'
		public Group getGroup() { return cGroup; }
		
		//preDefFunctionName=PredefineFunctions
		public Assignment getPreDefFunctionNameAssignment_0() { return cPreDefFunctionNameAssignment_0; }
		
		//PredefineFunctions
		public RuleCall getPreDefFunctionNamePredefineFunctionsParserRuleCall_0_0() { return cPreDefFunctionNamePredefineFunctionsParserRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//param=SubprogramParam
		public Assignment getParamAssignment_2() { return cParamAssignment_2; }
		
		//SubprogramParam
		public RuleCall getParamSubprogramParamParserRuleCall_2_0() { return cParamSubprogramParamParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class FunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.FunctionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFunctionCallAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFbNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cFbNameFunctionNameCrossReference_1_0 = (CrossReference)cFbNameAssignment_1.eContents().get(0);
		private final RuleCall cFbNameFunctionNameIDTerminalRuleCall_1_0_1 = (RuleCall)cFbNameFunctionNameCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cParamAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParamSubprogramParamParserRuleCall_3_0 = (RuleCall)cParamAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//FunctionCall Expression:
		//	{FunctionCall} fbName=[FunctionName] '(' param=SubprogramParam ')'
		@Override public ParserRule getRule() { return rule; }
		
		//{FunctionCall} fbName=[FunctionName] '(' param=SubprogramParam ')'
		public Group getGroup() { return cGroup; }
		
		//{FunctionCall}
		public Action getFunctionCallAction_0() { return cFunctionCallAction_0; }
		
		//fbName=[FunctionName]
		public Assignment getFbNameAssignment_1() { return cFbNameAssignment_1; }
		
		//[FunctionName]
		public CrossReference getFbNameFunctionNameCrossReference_1_0() { return cFbNameFunctionNameCrossReference_1_0; }
		
		//ID
		public RuleCall getFbNameFunctionNameIDTerminalRuleCall_1_0_1() { return cFbNameFunctionNameIDTerminalRuleCall_1_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//param=SubprogramParam
		public Assignment getParamAssignment_3() { return cParamAssignment_3; }
		
		//SubprogramParam
		public RuleCall getParamSubprogramParamParserRuleCall_3_0() { return cParamSubprogramParamParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class PredefineFunctionsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.PredefineFunctions");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cMaiuscKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cComprKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cRaizqKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cCopiaKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//PredefineFunctions:
		//	'maiusc' | 'compr' | 'raizq' | 'copia';
		@Override public ParserRule getRule() { return rule; }
		
		//'maiusc' | 'compr' | 'raizq' | 'copia'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'maiusc'
		public Keyword getMaiuscKeyword_0() { return cMaiuscKeyword_0; }
		
		//'compr'
		public Keyword getComprKeyword_1() { return cComprKeyword_1; }
		
		//'raizq'
		public Keyword getRaizqKeyword_2() { return cRaizqKeyword_2; }
		
		//'copia'
		public Keyword getCopiaKeyword_3() { return cCopiaKeyword_3; }
	}
	public class ProcedureCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.ProcedureCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cProcedureCallAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFbNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cFbNameProcedureNameCrossReference_1_0 = (CrossReference)cFbNameAssignment_1.eContents().get(0);
		private final RuleCall cFbNameProcedureNameIDTerminalRuleCall_1_0_1 = (RuleCall)cFbNameProcedureNameCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cParamAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParamSubprogramParamParserRuleCall_3_0 = (RuleCall)cParamAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ProcedureCall Expression:
		//	{ProcedureCall} fbName=[ProcedureName] '(' param=SubprogramParam ')'
		@Override public ParserRule getRule() { return rule; }
		
		//{ProcedureCall} fbName=[ProcedureName] '(' param=SubprogramParam ')'
		public Group getGroup() { return cGroup; }
		
		//{ProcedureCall}
		public Action getProcedureCallAction_0() { return cProcedureCallAction_0; }
		
		//fbName=[ProcedureName]
		public Assignment getFbNameAssignment_1() { return cFbNameAssignment_1; }
		
		//[ProcedureName]
		public CrossReference getFbNameProcedureNameCrossReference_1_0() { return cFbNameProcedureNameCrossReference_1_0; }
		
		//ID
		public RuleCall getFbNameProcedureNameIDTerminalRuleCall_1_0_1() { return cFbNameProcedureNameIDTerminalRuleCall_1_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//param=SubprogramParam
		public Assignment getParamAssignment_3() { return cParamAssignment_3; }
		
		//SubprogramParam
		public RuleCall getParamSubprogramParamParserRuleCall_3_0() { return cParamSubprogramParamParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumericLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBooleanLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Literal Expression:
		//	NumericLiteral
		//	| StringLiteral
		//	| BooleanLiteral
		@Override public ParserRule getRule() { return rule; }
		
		//NumericLiteral | StringLiteral | BooleanLiteral
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//NumericLiteral
		public RuleCall getNumericLiteralParserRuleCall_0() { return cNumericLiteralParserRuleCall_0; }
		
		//StringLiteral
		public RuleCall getStringLiteralParserRuleCall_1() { return cStringLiteralParserRuleCall_1; }
		
		//BooleanLiteral
		public RuleCall getBooleanLiteralParserRuleCall_2() { return cBooleanLiteralParserRuleCall_2; }
	}
	public class DeclaredVarElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.DeclaredVar");
		private final Assignment cVarNameAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cVarNameVarNameCrossReference_0 = (CrossReference)cVarNameAssignment.eContents().get(0);
		private final RuleCall cVarNameVarNameIDTerminalRuleCall_0_1 = (RuleCall)cVarNameVarNameCrossReference_0.eContents().get(1);
		
		//DeclaredVar:
		//	varName=[VarName];
		@Override public ParserRule getRule() { return rule; }
		
		//varName=[VarName]
		public Assignment getVarNameAssignment() { return cVarNameAssignment; }
		
		//[VarName]
		public CrossReference getVarNameVarNameCrossReference_0() { return cVarNameVarNameCrossReference_0; }
		
		//ID
		public RuleCall getVarNameVarNameIDTerminalRuleCall_0_1() { return cVarNameVarNameIDTerminalRuleCall_0_1; }
	}
	public class BooleanLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.BooleanLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cValueAlternatives_0 = (Alternatives)cValueAssignment.eContents().get(0);
		private final Keyword cValueVerdadeiroKeyword_0_0 = (Keyword)cValueAlternatives_0.eContents().get(0);
		private final Keyword cValueFalsoKeyword_0_1 = (Keyword)cValueAlternatives_0.eContents().get(1);
		
		//BooleanLiteral:
		//	value=('verdadeiro' | 'falso');
		@Override public ParserRule getRule() { return rule; }
		
		//value=('verdadeiro' | 'falso')
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//('verdadeiro' | 'falso')
		public Alternatives getValueAlternatives_0() { return cValueAlternatives_0; }
		
		//'verdadeiro'
		public Keyword getValueVerdadeiroKeyword_0_0() { return cValueVerdadeiroKeyword_0_0; }
		
		//'falso'
		public Keyword getValueFalsoKeyword_0_1() { return cValueFalsoKeyword_0_1; }
	}
	public class NumericLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.NumericLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFloatLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cPiLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//NumericLiteral:
		//	IntLiteral | FloatLiteral | PiLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//IntLiteral | FloatLiteral | PiLiteral
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IntLiteral
		public RuleCall getIntLiteralParserRuleCall_0() { return cIntLiteralParserRuleCall_0; }
		
		//FloatLiteral
		public RuleCall getFloatLiteralParserRuleCall_1() { return cFloatLiteralParserRuleCall_1; }
		
		//PiLiteral
		public RuleCall getPiLiteralParserRuleCall_2() { return cPiLiteralParserRuleCall_2; }
	}
	public class FloatLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.FloatLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueFLOATTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//FloatLiteral:
		//	value=FLOAT;
		@Override public ParserRule getRule() { return rule; }
		
		//value=FLOAT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//FLOAT
		public RuleCall getValueFLOATTerminalRuleCall_0() { return cValueFLOATTerminalRuleCall_0; }
	}
	public class IntLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.IntLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//IntLiteral:
		//	value=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//value=INT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_0() { return cValueINTTerminalRuleCall_0; }
	}
	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.StringLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StringLiteral:
		//	value=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//value=STRING
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}
	public class PiLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.PiLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cValuePiKeyword_0 = (Keyword)cValueAssignment.eContents().get(0);
		
		//PiLiteral:
		//	value='pi';
		@Override public ParserRule getRule() { return rule; }
		
		//value='pi'
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//'pi'
		public Keyword getValuePiKeyword_0() { return cValuePiKeyword_0; }
	}
	public class END_COMMANDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.END_COMMAND");
		private final Keyword cSemicolonKeyword = (Keyword)rule.eContents().get(1);
		
		//END_COMMAND:
		//	';';
		@Override public ParserRule getRule() { return rule; }
		
		//';'
		public Keyword getSemicolonKeyword() { return cSemicolonKeyword; }
	}
	
	
	private final ModelElements pModel;
	private final HeaderBlockElements pHeaderBlock;
	private final DeclarationsBlockElements pDeclarationsBlock;
	private final VariableElements pVariable;
	private final VarDeclarationElements pVarDeclaration;
	private final DeclaredVarListElements pDeclaredVarList;
	private final VarNameElements pVarName;
	private final VarTypeElements pVarType;
	private final SubprogramsElements pSubprograms;
	private final BlockSubProgramsElements pBlockSubPrograms;
	private final ProcedureNameElements pProcedureName;
	private final FunctionNameElements pFunctionName;
	private final BlockFunctionElements pBlockFunction;
	private final BlockProcedureElements pBlockProcedure;
	private final SubprogramParamDeclarationElements pSubprogramParamDeclaration;
	private final BlockCommandElements pBlockCommand;
	private final AbstractCommandElements pAbstractCommand;
	private final BreakStatementElements pBreakStatement;
	private final ReturnStatementElements pReturnStatement;
	private final IfStatementElements pIfStatement;
	private final SwitchCaseStatementElements pSwitchCaseStatement;
	private final CaseListElements pCaseList;
	private final OtherCaseElements pOtherCase;
	private final ForStatementElements pForStatement;
	private final WhileStatementElements pWhileStatement;
	private final RepeatStatementElements pRepeatStatement;
	private final SubprogramParamElements pSubprogramParam;
	private final ReadCommandElements pReadCommand;
	private final WriteCommandElements pWriteCommand;
	private final WriteParamElements pWriteParam;
	private final OptDecimalPrecisionElements pOptDecimalPrecision;
	private final ExpressionElements pExpression;
	private final AssignmentElements pAssignment;
	private final OrExpressionElements pOrExpression;
	private final XorExpressionElements pXorExpression;
	private final AndExpressionElements pAndExpression;
	private final ComparisonElements pComparison;
	private final EquExpressionElements pEquExpression;
	private final AddExpressionElements pAddExpression;
	private final MultiplicativeExpressionElements pMultiplicativeExpression;
	private final PowerExpressionElements pPowerExpression;
	private final AssignmentOperatorElements pAssignmentOperator;
	private final OrOperatorElements pOrOperator;
	private final XorOperatorElements pXorOperator;
	private final AndOperatorElements pAndOperator;
	private final ComparisonOperatorElements pComparisonOperator;
	private final EqualityOperatorElements pEqualityOperator;
	private final AddOperatorElements pAddOperator;
	private final MultiplicativeOperatorElements pMultiplicativeOperator;
	private final PowerOperatorElements pPowerOperator;
	private final NotOperatorElements pNotOperator;
	private final UnaryOperationElements pUnaryOperation;
	private final PrimaryExpressionElements pPrimaryExpression;
	private final PreDefinedFunctionCallElements pPreDefinedFunctionCall;
	private final FunctionCallElements pFunctionCall;
	private final PredefineFunctionsElements pPredefineFunctions;
	private final ProcedureCallElements pProcedureCall;
	private final LiteralElements pLiteral;
	private final DeclaredVarElements pDeclaredVar;
	private final BooleanLiteralElements pBooleanLiteral;
	private final NumericLiteralElements pNumericLiteral;
	private final FloatLiteralElements pFloatLiteral;
	private final IntLiteralElements pIntLiteral;
	private final StringLiteralElements pStringLiteral;
	private final PiLiteralElements pPiLiteral;
	private final TerminalRule tFLOAT;
	private final END_COMMANDElements pEND_COMMAND;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public PortugolGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pHeaderBlock = new HeaderBlockElements();
		this.pDeclarationsBlock = new DeclarationsBlockElements();
		this.pVariable = new VariableElements();
		this.pVarDeclaration = new VarDeclarationElements();
		this.pDeclaredVarList = new DeclaredVarListElements();
		this.pVarName = new VarNameElements();
		this.pVarType = new VarTypeElements();
		this.pSubprograms = new SubprogramsElements();
		this.pBlockSubPrograms = new BlockSubProgramsElements();
		this.pProcedureName = new ProcedureNameElements();
		this.pFunctionName = new FunctionNameElements();
		this.pBlockFunction = new BlockFunctionElements();
		this.pBlockProcedure = new BlockProcedureElements();
		this.pSubprogramParamDeclaration = new SubprogramParamDeclarationElements();
		this.pBlockCommand = new BlockCommandElements();
		this.pAbstractCommand = new AbstractCommandElements();
		this.pBreakStatement = new BreakStatementElements();
		this.pReturnStatement = new ReturnStatementElements();
		this.pIfStatement = new IfStatementElements();
		this.pSwitchCaseStatement = new SwitchCaseStatementElements();
		this.pCaseList = new CaseListElements();
		this.pOtherCase = new OtherCaseElements();
		this.pForStatement = new ForStatementElements();
		this.pWhileStatement = new WhileStatementElements();
		this.pRepeatStatement = new RepeatStatementElements();
		this.pSubprogramParam = new SubprogramParamElements();
		this.pReadCommand = new ReadCommandElements();
		this.pWriteCommand = new WriteCommandElements();
		this.pWriteParam = new WriteParamElements();
		this.pOptDecimalPrecision = new OptDecimalPrecisionElements();
		this.pExpression = new ExpressionElements();
		this.pAssignment = new AssignmentElements();
		this.pOrExpression = new OrExpressionElements();
		this.pXorExpression = new XorExpressionElements();
		this.pAndExpression = new AndExpressionElements();
		this.pComparison = new ComparisonElements();
		this.pEquExpression = new EquExpressionElements();
		this.pAddExpression = new AddExpressionElements();
		this.pMultiplicativeExpression = new MultiplicativeExpressionElements();
		this.pPowerExpression = new PowerExpressionElements();
		this.pAssignmentOperator = new AssignmentOperatorElements();
		this.pOrOperator = new OrOperatorElements();
		this.pXorOperator = new XorOperatorElements();
		this.pAndOperator = new AndOperatorElements();
		this.pComparisonOperator = new ComparisonOperatorElements();
		this.pEqualityOperator = new EqualityOperatorElements();
		this.pAddOperator = new AddOperatorElements();
		this.pMultiplicativeOperator = new MultiplicativeOperatorElements();
		this.pPowerOperator = new PowerOperatorElements();
		this.pNotOperator = new NotOperatorElements();
		this.pUnaryOperation = new UnaryOperationElements();
		this.pPrimaryExpression = new PrimaryExpressionElements();
		this.pPreDefinedFunctionCall = new PreDefinedFunctionCallElements();
		this.pFunctionCall = new FunctionCallElements();
		this.pPredefineFunctions = new PredefineFunctionsElements();
		this.pProcedureCall = new ProcedureCallElements();
		this.pLiteral = new LiteralElements();
		this.pDeclaredVar = new DeclaredVarElements();
		this.pBooleanLiteral = new BooleanLiteralElements();
		this.pNumericLiteral = new NumericLiteralElements();
		this.pFloatLiteral = new FloatLiteralElements();
		this.pIntLiteral = new IntLiteralElements();
		this.pStringLiteral = new StringLiteralElements();
		this.pPiLiteral = new PiLiteralElements();
		this.tFLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.FLOAT");
		this.pEND_COMMAND = new END_COMMANDElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.hopper.language.Portugol".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	header=HeaderBlock
	//	globalDeclarations=DeclarationsBlock?
	//	subprograms=Subprograms?
	//	commands=BlockCommand;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	//HeaderBlock:
	//	'algoritmo' algorithmName=STRING END_COMMAND;
	public HeaderBlockElements getHeaderBlockAccess() {
		return pHeaderBlock;
	}
	
	public ParserRule getHeaderBlockRule() {
		return getHeaderBlockAccess().getRule();
	}
	
	//DeclarationsBlock:
	//	'var' (vars+=Variable END_COMMAND)+;
	public DeclarationsBlockElements getDeclarationsBlockAccess() {
		return pDeclarationsBlock;
	}
	
	public ParserRule getDeclarationsBlockRule() {
		return getDeclarationsBlockAccess().getRule();
	}
	
	//Variable:
	//	varDeclaration=VarDeclaration ':' type=VarType;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//VarDeclaration:
	//	vars+=VarName (',' vars+=VarName)*;
	public VarDeclarationElements getVarDeclarationAccess() {
		return pVarDeclaration;
	}
	
	public ParserRule getVarDeclarationRule() {
		return getVarDeclarationAccess().getRule();
	}
	
	//DeclaredVarList:
	//	vars+=[VarName] (',' vars+=[VarName])*;
	public DeclaredVarListElements getDeclaredVarListAccess() {
		return pDeclaredVarList;
	}
	
	public ParserRule getDeclaredVarListRule() {
		return getDeclaredVarListAccess().getRule();
	}
	
	//VarName:
	//	name=ID;
	public VarNameElements getVarNameAccess() {
		return pVarName;
	}
	
	public ParserRule getVarNameRule() {
		return getVarNameAccess().getRule();
	}
	
	//VarType:
	//	typeName=('real' | 'inteiro' | 'caractere' | 'caracter' | 'logico');
	public VarTypeElements getVarTypeAccess() {
		return pVarType;
	}
	
	public ParserRule getVarTypeRule() {
		return getVarTypeAccess().getRule();
	}
	
	//Subprograms:
	//	blockSubPrograms+=BlockSubPrograms+;
	public SubprogramsElements getSubprogramsAccess() {
		return pSubprograms;
	}
	
	public ParserRule getSubprogramsRule() {
		return getSubprogramsAccess().getRule();
	}
	
	//BlockSubPrograms:
	//	BlockFunction | BlockProcedure;
	public BlockSubProgramsElements getBlockSubProgramsAccess() {
		return pBlockSubPrograms;
	}
	
	public ParserRule getBlockSubProgramsRule() {
		return getBlockSubProgramsAccess().getRule();
	}
	
	//ProcedureName:
	//	name=ID;
	public ProcedureNameElements getProcedureNameAccess() {
		return pProcedureName;
	}
	
	public ParserRule getProcedureNameRule() {
		return getProcedureNameAccess().getRule();
	}
	
	//FunctionName:
	//	name=ID;
	public FunctionNameElements getFunctionNameAccess() {
		return pFunctionName;
	}
	
	public ParserRule getFunctionNameRule() {
		return getFunctionNameAccess().getRule();
	}
	
	//BlockFunction:
	//	'funcao' functionName=FunctionName '(' params=SubprogramParamDeclaration? ')' ':' returnType=VarType
	//	declarations=DeclarationsBlock?
	//	'inicio'
	//	commands+=AbstractCommand+
	//	'fimfuncao';
	public BlockFunctionElements getBlockFunctionAccess() {
		return pBlockFunction;
	}
	
	public ParserRule getBlockFunctionRule() {
		return getBlockFunctionAccess().getRule();
	}
	
	//BlockProcedure:
	//	'procedimento' procedureName=ProcedureName '(' params=SubprogramParamDeclaration? ')'
	//	declarations=DeclarationsBlock?
	//	'inicio'
	//	commands+=AbstractCommand+
	//	'fimprocedimento';
	public BlockProcedureElements getBlockProcedureAccess() {
		return pBlockProcedure;
	}
	
	public ParserRule getBlockProcedureRule() {
		return getBlockProcedureAccess().getRule();
	}
	
	//SubprogramParamDeclaration:
	//	paramList+=Variable (';' paramList+=Variable)*;
	public SubprogramParamDeclarationElements getSubprogramParamDeclarationAccess() {
		return pSubprogramParamDeclaration;
	}
	
	public ParserRule getSubprogramParamDeclarationRule() {
		return getSubprogramParamDeclarationAccess().getRule();
	}
	
	//BlockCommand:
	//	'inicio'
	//	commands+=AbstractCommand+
	//	'fimalgoritmo';
	public BlockCommandElements getBlockCommandAccess() {
		return pBlockCommand;
	}
	
	public ParserRule getBlockCommandRule() {
		return getBlockCommandAccess().getRule();
	}
	
	//AbstractCommand:
	//	ReadCommand END_COMMAND
	//	| WriteCommand END_COMMAND
	//	| Expression END_COMMAND
	//	| IfStatement
	//	| SwitchCaseStatement
	//	| ForStatement
	//	| RepeatStatement
	//	| WhileStatement
	//	| BreakStatement END_COMMAND
	//	| ReturnStatement END_COMMAND;
	public AbstractCommandElements getAbstractCommandAccess() {
		return pAbstractCommand;
	}
	
	public ParserRule getAbstractCommandRule() {
		return getAbstractCommandAccess().getRule();
	}
	
	//BreakStatement:
	//	{BreakStatement} 'interrompa';
	public BreakStatementElements getBreakStatementAccess() {
		return pBreakStatement;
	}
	
	public ParserRule getBreakStatementRule() {
		return getBreakStatementAccess().getRule();
	}
	
	//ReturnStatement:
	//	{ReturnStatement} 'retorne' expr=Expression;
	public ReturnStatementElements getReturnStatementAccess() {
		return pReturnStatement;
	}
	
	public ParserRule getReturnStatementRule() {
		return getReturnStatementAccess().getRule();
	}
	
	//IfStatement:
	//	'se' expr=Expression 'entao'
	//	commands+=AbstractCommand+ ('senao' elseCommands+=AbstractCommand+)?
	//	'fimse';
	public IfStatementElements getIfStatementAccess() {
		return pIfStatement;
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}
	
	//SwitchCaseStatement:
	//	'escolha' variable=[VarName] caseList+=CaseList+
	//	otherCase=OtherCase?
	//	'fimescolha';
	public SwitchCaseStatementElements getSwitchCaseStatementAccess() {
		return pSwitchCaseStatement;
	}
	
	public ParserRule getSwitchCaseStatementRule() {
		return getSwitchCaseStatementAccess().getRule();
	}
	
	//CaseList:
	//	'caso' expr=Expression ':'
	//	commands+=AbstractCommand+;
	public CaseListElements getCaseListAccess() {
		return pCaseList;
	}
	
	public ParserRule getCaseListRule() {
		return getCaseListAccess().getRule();
	}
	
	//OtherCase:
	//	'outrocaso' ':'
	//	otherCaseCommands+=AbstractCommand+;
	public OtherCaseElements getOtherCaseAccess() {
		return pOtherCase;
	}
	
	public ParserRule getOtherCaseRule() {
		return getOtherCaseAccess().getRule();
	}
	
	//ForStatement:
	//	'para' operatorExpr=Expression 'de' startExpr=Expression 'ate' endExpr=Expression ('passo' stepExpe=Expression)?
	//	'faca'
	//	commands+=AbstractCommand+
	//	'fimpara';
	public ForStatementElements getForStatementAccess() {
		return pForStatement;
	}
	
	public ParserRule getForStatementRule() {
		return getForStatementAccess().getRule();
	}
	
	//WhileStatement:
	//	'enquanto' whileExpr=Expression 'faca'
	//	commands+=AbstractCommand+
	//	'fimenquanto';
	public WhileStatementElements getWhileStatementAccess() {
		return pWhileStatement;
	}
	
	public ParserRule getWhileStatementRule() {
		return getWhileStatementAccess().getRule();
	}
	
	//RepeatStatement:
	//	'repita'
	//	commands+=AbstractCommand+
	//	'ate' untilExpr=Expression END_COMMAND;
	public RepeatStatementElements getRepeatStatementAccess() {
		return pRepeatStatement;
	}
	
	public ParserRule getRepeatStatementRule() {
		return getRepeatStatementAccess().getRule();
	}
	
	//SubprogramParam:
	//	expression+=Expression (',' expression+=Expression)*;
	public SubprogramParamElements getSubprogramParamAccess() {
		return pSubprogramParam;
	}
	
	public ParserRule getSubprogramParamRule() {
		return getSubprogramParamAccess().getRule();
	}
	
	//ReadCommand:
	//	'leia' '(' paramList=DeclaredVarList ')';
	public ReadCommandElements getReadCommandAccess() {
		return pReadCommand;
	}
	
	public ParserRule getReadCommandRule() {
		return getReadCommandAccess().getRule();
	}
	
	//WriteCommand:
	//	writeCommand=('escreva' | 'escreval') '(' writeParam=WriteParam ')';
	public WriteCommandElements getWriteCommandAccess() {
		return pWriteCommand;
	}
	
	public ParserRule getWriteCommandRule() {
		return getWriteCommandAccess().getRule();
	}
	
	//WriteParam:
	//	params=SubprogramParam precision=OptDecimalPrecision?;
	public WriteParamElements getWriteParamAccess() {
		return pWriteParam;
	}
	
	public ParserRule getWriteParamRule() {
		return getWriteParamAccess().getRule();
	}
	
	//OptDecimalPrecision:
	//	':' firstPrecision=INT (':' secondPrecision=INT)?;
	public OptDecimalPrecisionElements getOptDecimalPrecisionAccess() {
		return pOptDecimalPrecision;
	}
	
	public ParserRule getOptDecimalPrecisionRule() {
		return getOptDecimalPrecisionAccess().getRule();
	}
	
	//Expression:
	//	Assignment;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//Assignment Expression:
	//	OrExpression (=> ({BinaryOperation.left=current} op=AssignmentOperator) right=Assignment)*
	public AssignmentElements getAssignmentAccess() {
		return pAssignment;
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}
	
	//OrExpression Expression:
	//	XorExpression (=> ({BinaryOperation.left=current} op=OrOperator) right=XorExpression)*
	public OrExpressionElements getOrExpressionAccess() {
		return pOrExpression;
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}
	
	//XorExpression Expression:
	//	AndExpression (=> ({BinaryOperation.left=current} op=XorOperator) right=AndExpression)*
	public XorExpressionElements getXorExpressionAccess() {
		return pXorExpression;
	}
	
	public ParserRule getXorExpressionRule() {
		return getXorExpressionAccess().getRule();
	}
	
	//AndExpression Expression:
	//	Comparison (=> ({BinaryOperation.left=current} op=AndOperator) right=Comparison)*
	public AndExpressionElements getAndExpressionAccess() {
		return pAndExpression;
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}
	
	//Comparison Expression:
	//	EquExpression (=> ({BinaryOperation.left=current} op=ComparisonOperator) right=EquExpression)*
	public ComparisonElements getComparisonAccess() {
		return pComparison;
	}
	
	public ParserRule getComparisonRule() {
		return getComparisonAccess().getRule();
	}
	
	//EquExpression Expression:
	//	AddExpression (=> ({BinaryOperation.left=current} op=EqualityOperator) right=AddExpression)*
	public EquExpressionElements getEquExpressionAccess() {
		return pEquExpression;
	}
	
	public ParserRule getEquExpressionRule() {
		return getEquExpressionAccess().getRule();
	}
	
	//AddExpression Expression:
	//	MultiplicativeExpression (=> ({BinaryOperation.left=current} op=AddOperator) right=MultiplicativeExpression)*
	public AddExpressionElements getAddExpressionAccess() {
		return pAddExpression;
	}
	
	public ParserRule getAddExpressionRule() {
		return getAddExpressionAccess().getRule();
	}
	
	//MultiplicativeExpression Expression:
	//	PowerExpression (=> ({BinaryOperation.left=current} op=MultiplicativeOperator) right=PowerExpression)*
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return pMultiplicativeExpression;
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}
	
	//PowerExpression Expression:
	//	UnaryOperation (=> ({BinaryOperation.left=current} op=PowerOperator) right=UnaryOperation)*
	public PowerExpressionElements getPowerExpressionAccess() {
		return pPowerExpression;
	}
	
	public ParserRule getPowerExpressionRule() {
		return getPowerExpressionAccess().getRule();
	}
	
	//AssignmentOperator Operator:
	//	op='<-'
	public AssignmentOperatorElements getAssignmentOperatorAccess() {
		return pAssignmentOperator;
	}
	
	public ParserRule getAssignmentOperatorRule() {
		return getAssignmentOperatorAccess().getRule();
	}
	
	//OrOperator Operator:
	//	op='OU'
	public OrOperatorElements getOrOperatorAccess() {
		return pOrOperator;
	}
	
	public ParserRule getOrOperatorRule() {
		return getOrOperatorAccess().getRule();
	}
	
	//XorOperator Operator:
	//	op='XOU'
	public XorOperatorElements getXorOperatorAccess() {
		return pXorOperator;
	}
	
	public ParserRule getXorOperatorRule() {
		return getXorOperatorAccess().getRule();
	}
	
	//AndOperator Operator:
	//	op='E'
	public AndOperatorElements getAndOperatorAccess() {
		return pAndOperator;
	}
	
	public ParserRule getAndOperatorRule() {
		return getAndOperatorAccess().getRule();
	}
	
	//ComparisonOperator Operator:
	//	op=('=' | '<>')
	public ComparisonOperatorElements getComparisonOperatorAccess() {
		return pComparisonOperator;
	}
	
	public ParserRule getComparisonOperatorRule() {
		return getComparisonOperatorAccess().getRule();
	}
	
	//EqualityOperator Operator:
	//	op=('<' | '>' | '<=' | '>=')
	public EqualityOperatorElements getEqualityOperatorAccess() {
		return pEqualityOperator;
	}
	
	public ParserRule getEqualityOperatorRule() {
		return getEqualityOperatorAccess().getRule();
	}
	
	//AddOperator Operator:
	//	op=('+' | '-')
	public AddOperatorElements getAddOperatorAccess() {
		return pAddOperator;
	}
	
	public ParserRule getAddOperatorRule() {
		return getAddOperatorAccess().getRule();
	}
	
	//MultiplicativeOperator Operator:
	//	op=('*' | '/' | 'MOD' | '%')
	public MultiplicativeOperatorElements getMultiplicativeOperatorAccess() {
		return pMultiplicativeOperator;
	}
	
	public ParserRule getMultiplicativeOperatorRule() {
		return getMultiplicativeOperatorAccess().getRule();
	}
	
	//PowerOperator Operator:
	//	op='^'
	public PowerOperatorElements getPowerOperatorAccess() {
		return pPowerOperator;
	}
	
	public ParserRule getPowerOperatorRule() {
		return getPowerOperatorAccess().getRule();
	}
	
	//NotOperator Operator:
	//	op=('NAO' | '-')
	public NotOperatorElements getNotOperatorAccess() {
		return pNotOperator;
	}
	
	public ParserRule getNotOperatorRule() {
		return getNotOperatorAccess().getRule();
	}
	
	//UnaryOperation Expression:
	//	{UnaryOperation} op=NotOperator operand=UnaryOperation / * right associativity * /
	//	| PrimaryExpression
	public UnaryOperationElements getUnaryOperationAccess() {
		return pUnaryOperation;
	}
	
	public ParserRule getUnaryOperationRule() {
		return getUnaryOperationAccess().getRule();
	}
	
	//PrimaryExpression Expression:
	//	Literal
	//	| PreDefinedFunctionCall
	//	| FunctionCall
	//	| DeclaredVar
	//	| '(' Expression ')'
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return pPrimaryExpression;
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}
	
	//PreDefinedFunctionCall Expression:
	//	preDefFunctionName=PredefineFunctions '(' param=SubprogramParam ')'
	public PreDefinedFunctionCallElements getPreDefinedFunctionCallAccess() {
		return pPreDefinedFunctionCall;
	}
	
	public ParserRule getPreDefinedFunctionCallRule() {
		return getPreDefinedFunctionCallAccess().getRule();
	}
	
	//FunctionCall Expression:
	//	{FunctionCall} fbName=[FunctionName] '(' param=SubprogramParam ')'
	public FunctionCallElements getFunctionCallAccess() {
		return pFunctionCall;
	}
	
	public ParserRule getFunctionCallRule() {
		return getFunctionCallAccess().getRule();
	}
	
	//PredefineFunctions:
	//	'maiusc' | 'compr' | 'raizq' | 'copia';
	public PredefineFunctionsElements getPredefineFunctionsAccess() {
		return pPredefineFunctions;
	}
	
	public ParserRule getPredefineFunctionsRule() {
		return getPredefineFunctionsAccess().getRule();
	}
	
	//ProcedureCall Expression:
	//	{ProcedureCall} fbName=[ProcedureName] '(' param=SubprogramParam ')'
	public ProcedureCallElements getProcedureCallAccess() {
		return pProcedureCall;
	}
	
	public ParserRule getProcedureCallRule() {
		return getProcedureCallAccess().getRule();
	}
	
	//Literal Expression:
	//	NumericLiteral
	//	| StringLiteral
	//	| BooleanLiteral
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}
	
	//DeclaredVar:
	//	varName=[VarName];
	public DeclaredVarElements getDeclaredVarAccess() {
		return pDeclaredVar;
	}
	
	public ParserRule getDeclaredVarRule() {
		return getDeclaredVarAccess().getRule();
	}
	
	//BooleanLiteral:
	//	value=('verdadeiro' | 'falso');
	public BooleanLiteralElements getBooleanLiteralAccess() {
		return pBooleanLiteral;
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}
	
	//NumericLiteral:
	//	IntLiteral | FloatLiteral | PiLiteral;
	public NumericLiteralElements getNumericLiteralAccess() {
		return pNumericLiteral;
	}
	
	public ParserRule getNumericLiteralRule() {
		return getNumericLiteralAccess().getRule();
	}
	
	//FloatLiteral:
	//	value=FLOAT;
	public FloatLiteralElements getFloatLiteralAccess() {
		return pFloatLiteral;
	}
	
	public ParserRule getFloatLiteralRule() {
		return getFloatLiteralAccess().getRule();
	}
	
	//IntLiteral:
	//	value=INT;
	public IntLiteralElements getIntLiteralAccess() {
		return pIntLiteral;
	}
	
	public ParserRule getIntLiteralRule() {
		return getIntLiteralAccess().getRule();
	}
	
	//StringLiteral:
	//	value=STRING;
	public StringLiteralElements getStringLiteralAccess() {
		return pStringLiteral;
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}
	
	//PiLiteral:
	//	value='pi';
	public PiLiteralElements getPiLiteralAccess() {
		return pPiLiteral;
	}
	
	public ParserRule getPiLiteralRule() {
		return getPiLiteralAccess().getRule();
	}
	
	//terminal FLOAT returns ecore::EFloat:
	//	INT+ '.' INT+;
	public TerminalRule getFLOATRule() {
		return tFLOAT;
	}
	
	//END_COMMAND:
	//	';';
	public END_COMMANDElements getEND_COMMANDAccess() {
		return pEND_COMMAND;
	}
	
	public ParserRule getEND_COMMANDRule() {
		return getEND_COMMANDAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}

/*
 * generated by Xtext 2.9.0
 */
package org.hopper.language.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class PortugolGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cHeaderAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cHeaderHeaderBlockParserRuleCall_0_0 = (RuleCall)cHeaderAssignment_0.eContents().get(0);
		private final Assignment cGlobalDeclarationsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cGlobalDeclarationsDeclarationsBlockParserRuleCall_1_0 = (RuleCall)cGlobalDeclarationsAssignment_1.eContents().get(0);
		private final Assignment cSubprogramsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSubprogramsSubprogramsParserRuleCall_2_0 = (RuleCall)cSubprogramsAssignment_2.eContents().get(0);
		private final Assignment cCommandsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCommandsBlockCommandParserRuleCall_3_0 = (RuleCall)cCommandsAssignment_3.eContents().get(0);
		
		//Model:
		//	header=HeaderBlock
		//	globalDeclarations=DeclarationsBlock
		//	subprograms=Subprograms?
		//	commands=BlockCommand;
		@Override public ParserRule getRule() { return rule; }
		
		//header=HeaderBlock globalDeclarations=DeclarationsBlock subprograms=Subprograms? commands=BlockCommand
		public Group getGroup() { return cGroup; }
		
		//header=HeaderBlock
		public Assignment getHeaderAssignment_0() { return cHeaderAssignment_0; }
		
		//HeaderBlock
		public RuleCall getHeaderHeaderBlockParserRuleCall_0_0() { return cHeaderHeaderBlockParserRuleCall_0_0; }
		
		//globalDeclarations=DeclarationsBlock
		public Assignment getGlobalDeclarationsAssignment_1() { return cGlobalDeclarationsAssignment_1; }
		
		//DeclarationsBlock
		public RuleCall getGlobalDeclarationsDeclarationsBlockParserRuleCall_1_0() { return cGlobalDeclarationsDeclarationsBlockParserRuleCall_1_0; }
		
		//subprograms=Subprograms?
		public Assignment getSubprogramsAssignment_2() { return cSubprogramsAssignment_2; }
		
		//Subprograms
		public RuleCall getSubprogramsSubprogramsParserRuleCall_2_0() { return cSubprogramsSubprogramsParserRuleCall_2_0; }
		
		//commands=BlockCommand
		public Assignment getCommandsAssignment_3() { return cCommandsAssignment_3; }
		
		//BlockCommand
		public RuleCall getCommandsBlockCommandParserRuleCall_3_0() { return cCommandsBlockCommandParserRuleCall_3_0; }
	}
	public class HeaderBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.HeaderBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAlgoritmoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final RuleCall cEND_COMMANDTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//HeaderBlock:
		//	'algoritmo' name=STRING END_COMMAND;
		@Override public ParserRule getRule() { return rule; }
		
		//'algoritmo' name=STRING END_COMMAND
		public Group getGroup() { return cGroup; }
		
		//'algoritmo'
		public Keyword getAlgoritmoKeyword_0() { return cAlgoritmoKeyword_0; }
		
		//name=STRING
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0() { return cNameSTRINGTerminalRuleCall_1_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_2() { return cEND_COMMANDTerminalRuleCall_2; }
	}
	public class DeclarationsBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.DeclarationsBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVarKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cEND_COMMANDTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cVarsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cVarsVariableParserRuleCall_2_0_0 = (RuleCall)cVarsAssignment_2_0.eContents().get(0);
		private final RuleCall cEND_COMMANDTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		
		//DeclarationsBlock:
		//	'var' END_COMMAND (vars+=Variable END_COMMAND)+;
		@Override public ParserRule getRule() { return rule; }
		
		//'var' END_COMMAND (vars+=Variable END_COMMAND)+
		public Group getGroup() { return cGroup; }
		
		//'var'
		public Keyword getVarKeyword_0() { return cVarKeyword_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_1() { return cEND_COMMANDTerminalRuleCall_1; }
		
		//(vars+=Variable END_COMMAND)+
		public Group getGroup_2() { return cGroup_2; }
		
		//vars+=Variable
		public Assignment getVarsAssignment_2_0() { return cVarsAssignment_2_0; }
		
		//Variable
		public RuleCall getVarsVariableParserRuleCall_2_0_0() { return cVarsVariableParserRuleCall_2_0_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_2_1() { return cEND_COMMANDTerminalRuleCall_2_1; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarDeclarationAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarDeclarationVarDeclarationParserRuleCall_0_0 = (RuleCall)cVarDeclarationAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeVarTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//Variable:
		//	varDeclaration=VarDeclaration ':' type=VarType;
		@Override public ParserRule getRule() { return rule; }
		
		//varDeclaration=VarDeclaration ':' type=VarType
		public Group getGroup() { return cGroup; }
		
		//varDeclaration=VarDeclaration
		public Assignment getVarDeclarationAssignment_0() { return cVarDeclarationAssignment_0; }
		
		//VarDeclaration
		public RuleCall getVarDeclarationVarDeclarationParserRuleCall_0_0() { return cVarDeclarationVarDeclarationParserRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=VarType
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//VarType
		public RuleCall getTypeVarTypeParserRuleCall_2_0() { return cTypeVarTypeParserRuleCall_2_0; }
	}
	public class VarDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.VarDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarsVarNameParserRuleCall_0_0 = (RuleCall)cVarsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cVarsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cVarsVarNameParserRuleCall_1_1_0 = (RuleCall)cVarsAssignment_1_1.eContents().get(0);
		
		//VarDeclaration:
		//	vars+=VarName (',' vars+=VarName)*;
		@Override public ParserRule getRule() { return rule; }
		
		//vars+=VarName (',' vars+=VarName)*
		public Group getGroup() { return cGroup; }
		
		//vars+=VarName
		public Assignment getVarsAssignment_0() { return cVarsAssignment_0; }
		
		//VarName
		public RuleCall getVarsVarNameParserRuleCall_0_0() { return cVarsVarNameParserRuleCall_0_0; }
		
		//(',' vars+=VarName)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//vars+=VarName
		public Assignment getVarsAssignment_1_1() { return cVarsAssignment_1_1; }
		
		//VarName
		public RuleCall getVarsVarNameParserRuleCall_1_1_0() { return cVarsVarNameParserRuleCall_1_1_0; }
	}
	public class DeclaredVarElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.DeclaredVar");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cVarsVarNameCrossReference_0_0 = (CrossReference)cVarsAssignment_0.eContents().get(0);
		private final RuleCall cVarsVarNameIDTerminalRuleCall_0_0_1 = (RuleCall)cVarsVarNameCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cVarsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final CrossReference cVarsVarNameCrossReference_1_1_0 = (CrossReference)cVarsAssignment_1_1.eContents().get(0);
		private final RuleCall cVarsVarNameIDTerminalRuleCall_1_1_0_1 = (RuleCall)cVarsVarNameCrossReference_1_1_0.eContents().get(1);
		
		//DeclaredVar:
		//	vars+=[VarName] (',' vars+=[VarName])*;
		@Override public ParserRule getRule() { return rule; }
		
		//vars+=[VarName] (',' vars+=[VarName])*
		public Group getGroup() { return cGroup; }
		
		//vars+=[VarName]
		public Assignment getVarsAssignment_0() { return cVarsAssignment_0; }
		
		//[VarName]
		public CrossReference getVarsVarNameCrossReference_0_0() { return cVarsVarNameCrossReference_0_0; }
		
		//ID
		public RuleCall getVarsVarNameIDTerminalRuleCall_0_0_1() { return cVarsVarNameIDTerminalRuleCall_0_0_1; }
		
		//(',' vars+=[VarName])*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//vars+=[VarName]
		public Assignment getVarsAssignment_1_1() { return cVarsAssignment_1_1; }
		
		//[VarName]
		public CrossReference getVarsVarNameCrossReference_1_1_0() { return cVarsVarNameCrossReference_1_1_0; }
		
		//ID
		public RuleCall getVarsVarNameIDTerminalRuleCall_1_1_0_1() { return cVarsVarNameIDTerminalRuleCall_1_1_0_1; }
	}
	public class VarNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.VarName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//VarName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class VarTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.VarType");
		private final Assignment cTypeNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cTypeNameAlternatives_0 = (Alternatives)cTypeNameAssignment.eContents().get(0);
		private final Keyword cTypeNameRealKeyword_0_0 = (Keyword)cTypeNameAlternatives_0.eContents().get(0);
		private final Keyword cTypeNameInteiroKeyword_0_1 = (Keyword)cTypeNameAlternatives_0.eContents().get(1);
		private final Keyword cTypeNameCaractereKeyword_0_2 = (Keyword)cTypeNameAlternatives_0.eContents().get(2);
		
		//VarType:
		//	typeName=('real' | 'inteiro' | 'caractere');
		@Override public ParserRule getRule() { return rule; }
		
		//typeName=('real' | 'inteiro' | 'caractere')
		public Assignment getTypeNameAssignment() { return cTypeNameAssignment; }
		
		//('real' | 'inteiro' | 'caractere')
		public Alternatives getTypeNameAlternatives_0() { return cTypeNameAlternatives_0; }
		
		//'real'
		public Keyword getTypeNameRealKeyword_0_0() { return cTypeNameRealKeyword_0_0; }
		
		//'inteiro'
		public Keyword getTypeNameInteiroKeyword_0_1() { return cTypeNameInteiroKeyword_0_1; }
		
		//'caractere'
		public Keyword getTypeNameCaractereKeyword_0_2() { return cTypeNameCaractereKeyword_0_2; }
	}
	public class SubprogramsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Subprograms");
		private final Assignment cBlockSubProgramsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cBlockSubProgramsBlockSubProgramsParserRuleCall_0 = (RuleCall)cBlockSubProgramsAssignment.eContents().get(0);
		
		//Subprograms:
		//	blockSubPrograms+=BlockSubPrograms+;
		@Override public ParserRule getRule() { return rule; }
		
		//blockSubPrograms+=BlockSubPrograms+
		public Assignment getBlockSubProgramsAssignment() { return cBlockSubProgramsAssignment; }
		
		//BlockSubPrograms
		public RuleCall getBlockSubProgramsBlockSubProgramsParserRuleCall_0() { return cBlockSubProgramsBlockSubProgramsParserRuleCall_0; }
	}
	public class BlockSubProgramsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.BlockSubPrograms");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBlockFunctionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBlockProcedureParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//BlockSubPrograms:
		//	BlockFunction | BlockProcedure;
		@Override public ParserRule getRule() { return rule; }
		
		//BlockFunction | BlockProcedure
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BlockFunction
		public RuleCall getBlockFunctionParserRuleCall_0() { return cBlockFunctionParserRuleCall_0; }
		
		//BlockProcedure
		public RuleCall getBlockProcedureParserRuleCall_1() { return cBlockProcedureParserRuleCall_1; }
	}
	public class FunctionNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.FunctionName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//FunctionName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class ProcedureNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.ProcedureName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//ProcedureName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class BlockFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.BlockFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFuncaoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFunctionNameFunctionNameParserRuleCall_1_0 = (RuleCall)cFunctionNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cParamListAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParamListVariableParserRuleCall_3_0 = (RuleCall)cParamListAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cColonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cReturnTypeAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cReturnTypeVarTypeParserRuleCall_6_0 = (RuleCall)cReturnTypeAssignment_6.eContents().get(0);
		private final RuleCall cEND_COMMANDTerminalRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		private final Assignment cDeclarationsAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cDeclarationsDeclarationsBlockParserRuleCall_8_0 = (RuleCall)cDeclarationsAssignment_8.eContents().get(0);
		private final Keyword cInicioKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final RuleCall cEND_COMMANDTerminalRuleCall_10 = (RuleCall)cGroup.eContents().get(10);
		private final Assignment cCommandsAssignment_11 = (Assignment)cGroup.eContents().get(11);
		private final RuleCall cCommandsAbstractCommandParserRuleCall_11_0 = (RuleCall)cCommandsAssignment_11.eContents().get(0);
		private final Keyword cFimfuncaoKeyword_12 = (Keyword)cGroup.eContents().get(12);
		private final RuleCall cEND_COMMANDTerminalRuleCall_13 = (RuleCall)cGroup.eContents().get(13);
		
		//BlockFunction:
		//	'funcao' functionName=FunctionName '(' paramList=Variable ')' ':' returnType=VarType END_COMMAND
		//	declarations=DeclarationsBlock?
		//	'inicio' END_COMMAND
		//	commands+=AbstractCommand+
		//	'fimfuncao' END_COMMAND;
		@Override public ParserRule getRule() { return rule; }
		
		//'funcao' functionName=FunctionName '(' paramList=Variable ')' ':' returnType=VarType END_COMMAND
		//declarations=DeclarationsBlock? 'inicio' END_COMMAND commands+=AbstractCommand+ 'fimfuncao' END_COMMAND
		public Group getGroup() { return cGroup; }
		
		//'funcao'
		public Keyword getFuncaoKeyword_0() { return cFuncaoKeyword_0; }
		
		//functionName=FunctionName
		public Assignment getFunctionNameAssignment_1() { return cFunctionNameAssignment_1; }
		
		//FunctionName
		public RuleCall getFunctionNameFunctionNameParserRuleCall_1_0() { return cFunctionNameFunctionNameParserRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//paramList=Variable
		public Assignment getParamListAssignment_3() { return cParamListAssignment_3; }
		
		//Variable
		public RuleCall getParamListVariableParserRuleCall_3_0() { return cParamListVariableParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//':'
		public Keyword getColonKeyword_5() { return cColonKeyword_5; }
		
		//returnType=VarType
		public Assignment getReturnTypeAssignment_6() { return cReturnTypeAssignment_6; }
		
		//VarType
		public RuleCall getReturnTypeVarTypeParserRuleCall_6_0() { return cReturnTypeVarTypeParserRuleCall_6_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_7() { return cEND_COMMANDTerminalRuleCall_7; }
		
		//declarations=DeclarationsBlock?
		public Assignment getDeclarationsAssignment_8() { return cDeclarationsAssignment_8; }
		
		//DeclarationsBlock
		public RuleCall getDeclarationsDeclarationsBlockParserRuleCall_8_0() { return cDeclarationsDeclarationsBlockParserRuleCall_8_0; }
		
		//'inicio'
		public Keyword getInicioKeyword_9() { return cInicioKeyword_9; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_10() { return cEND_COMMANDTerminalRuleCall_10; }
		
		//commands+=AbstractCommand+
		public Assignment getCommandsAssignment_11() { return cCommandsAssignment_11; }
		
		//AbstractCommand
		public RuleCall getCommandsAbstractCommandParserRuleCall_11_0() { return cCommandsAbstractCommandParserRuleCall_11_0; }
		
		//'fimfuncao'
		public Keyword getFimfuncaoKeyword_12() { return cFimfuncaoKeyword_12; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_13() { return cEND_COMMANDTerminalRuleCall_13; }
	}
	public class BlockProcedureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.BlockProcedure");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cProcedimentoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cProcedureAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cProcedureProcedureNameParserRuleCall_1_0 = (RuleCall)cProcedureAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cParamListAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParamListVariableParserRuleCall_3_0 = (RuleCall)cParamListAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final RuleCall cEND_COMMANDTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final Assignment cDeclarationsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cDeclarationsDeclarationsBlockParserRuleCall_6_0 = (RuleCall)cDeclarationsAssignment_6.eContents().get(0);
		private final Keyword cInicioKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final RuleCall cEND_COMMANDTerminalRuleCall_8 = (RuleCall)cGroup.eContents().get(8);
		private final Assignment cCommandsAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cCommandsAbstractCommandParserRuleCall_9_0 = (RuleCall)cCommandsAssignment_9.eContents().get(0);
		private final Keyword cFimprocedimentoKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final RuleCall cEND_COMMANDTerminalRuleCall_11 = (RuleCall)cGroup.eContents().get(11);
		
		//BlockProcedure:
		//	'procedimento' procedure=ProcedureName '(' paramList=Variable ')' END_COMMAND
		//	declarations=DeclarationsBlock?
		//	'inicio' END_COMMAND
		//	commands+=AbstractCommand+
		//	'fimprocedimento' END_COMMAND;
		@Override public ParserRule getRule() { return rule; }
		
		//'procedimento' procedure=ProcedureName '(' paramList=Variable ')' END_COMMAND declarations=DeclarationsBlock? 'inicio'
		//END_COMMAND commands+=AbstractCommand+ 'fimprocedimento' END_COMMAND
		public Group getGroup() { return cGroup; }
		
		//'procedimento'
		public Keyword getProcedimentoKeyword_0() { return cProcedimentoKeyword_0; }
		
		//procedure=ProcedureName
		public Assignment getProcedureAssignment_1() { return cProcedureAssignment_1; }
		
		//ProcedureName
		public RuleCall getProcedureProcedureNameParserRuleCall_1_0() { return cProcedureProcedureNameParserRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//paramList=Variable
		public Assignment getParamListAssignment_3() { return cParamListAssignment_3; }
		
		//Variable
		public RuleCall getParamListVariableParserRuleCall_3_0() { return cParamListVariableParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_5() { return cEND_COMMANDTerminalRuleCall_5; }
		
		//declarations=DeclarationsBlock?
		public Assignment getDeclarationsAssignment_6() { return cDeclarationsAssignment_6; }
		
		//DeclarationsBlock
		public RuleCall getDeclarationsDeclarationsBlockParserRuleCall_6_0() { return cDeclarationsDeclarationsBlockParserRuleCall_6_0; }
		
		//'inicio'
		public Keyword getInicioKeyword_7() { return cInicioKeyword_7; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_8() { return cEND_COMMANDTerminalRuleCall_8; }
		
		//commands+=AbstractCommand+
		public Assignment getCommandsAssignment_9() { return cCommandsAssignment_9; }
		
		//AbstractCommand
		public RuleCall getCommandsAbstractCommandParserRuleCall_9_0() { return cCommandsAbstractCommandParserRuleCall_9_0; }
		
		//'fimprocedimento'
		public Keyword getFimprocedimentoKeyword_10() { return cFimprocedimentoKeyword_10; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_11() { return cEND_COMMANDTerminalRuleCall_11; }
	}
	public class BlockCommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.BlockCommand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInicioKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cEND_COMMANDTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cCommandsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCommandsAbstractCommandParserRuleCall_2_0 = (RuleCall)cCommandsAssignment_2.eContents().get(0);
		private final Keyword cFimalgoritmoKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final RuleCall cEND_COMMANDTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//BlockCommand:
		//	'inicio' END_COMMAND
		//	commands+=AbstractCommand+
		//	'fimalgoritmo' END_COMMAND;
		@Override public ParserRule getRule() { return rule; }
		
		//'inicio' END_COMMAND commands+=AbstractCommand+ 'fimalgoritmo' END_COMMAND
		public Group getGroup() { return cGroup; }
		
		//'inicio'
		public Keyword getInicioKeyword_0() { return cInicioKeyword_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_1() { return cEND_COMMANDTerminalRuleCall_1; }
		
		//commands+=AbstractCommand+
		public Assignment getCommandsAssignment_2() { return cCommandsAssignment_2; }
		
		//AbstractCommand
		public RuleCall getCommandsAbstractCommandParserRuleCall_2_0() { return cCommandsAbstractCommandParserRuleCall_2_0; }
		
		//'fimalgoritmo'
		public Keyword getFimalgoritmoKeyword_3() { return cFimalgoritmoKeyword_3; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_4() { return cEND_COMMANDTerminalRuleCall_4; }
	}
	public class AbstractCommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.AbstractCommand");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cReadCommandParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cEND_COMMANDTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cWriteCommandParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cEND_COMMANDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cExpressionParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final RuleCall cEND_COMMANDTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		
		//AbstractCommand:
		//	ReadCommand END_COMMAND
		//	| WriteCommand END_COMMAND
		//	| Expression END_COMMAND;
		@Override public ParserRule getRule() { return rule; }
		
		//ReadCommand END_COMMAND | WriteCommand END_COMMAND | Expression END_COMMAND
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ReadCommand END_COMMAND
		public Group getGroup_0() { return cGroup_0; }
		
		//ReadCommand
		public RuleCall getReadCommandParserRuleCall_0_0() { return cReadCommandParserRuleCall_0_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_0_1() { return cEND_COMMANDTerminalRuleCall_0_1; }
		
		//WriteCommand END_COMMAND
		public Group getGroup_1() { return cGroup_1; }
		
		//WriteCommand
		public RuleCall getWriteCommandParserRuleCall_1_0() { return cWriteCommandParserRuleCall_1_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_1_1() { return cEND_COMMANDTerminalRuleCall_1_1; }
		
		//Expression END_COMMAND
		public Group getGroup_2() { return cGroup_2; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_2_0() { return cExpressionParserRuleCall_2_0; }
		
		//END_COMMAND
		public RuleCall getEND_COMMANDTerminalRuleCall_2_1() { return cEND_COMMANDTerminalRuleCall_2_1; }
	}
	public class ReadCommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.ReadCommand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeiaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParamListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParamListDeclaredVarParserRuleCall_2_0 = (RuleCall)cParamListAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ReadCommand:
		//	'leia' '(' paramList=DeclaredVar ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'leia' '(' paramList=DeclaredVar ')'
		public Group getGroup() { return cGroup; }
		
		//'leia'
		public Keyword getLeiaKeyword_0() { return cLeiaKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//paramList=DeclaredVar
		public Assignment getParamListAssignment_2() { return cParamListAssignment_2; }
		
		//DeclaredVar
		public RuleCall getParamListDeclaredVarParserRuleCall_2_0() { return cParamListDeclaredVarParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class WriteCommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.WriteCommand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEscrevaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cWriteParamAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cWriteParamWriteParamParserRuleCall_2_0 = (RuleCall)cWriteParamAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//WriteCommand:
		//	'escreva' '(' writeParam=WriteParam ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'escreva' '(' writeParam=WriteParam ')'
		public Group getGroup() { return cGroup; }
		
		//'escreva'
		public Keyword getEscrevaKeyword_0() { return cEscrevaKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//writeParam=WriteParam
		public Assignment getWriteParamAssignment_2() { return cWriteParamAssignment_2; }
		
		//WriteParam
		public RuleCall getWriteParamWriteParamParserRuleCall_2_0() { return cWriteParamWriteParamParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class WriteParamElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.WriteParam");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionExpressionParserRuleCall_0_0 = (RuleCall)cExpressionAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cExpressionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_1_0 = (RuleCall)cExpressionAssignment_1_1.eContents().get(0);
		private final Assignment cPrecisionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPrecisionOptDecimalPrecisionParserRuleCall_2_0 = (RuleCall)cPrecisionAssignment_2.eContents().get(0);
		
		//WriteParam:
		//	expression+=Expression (',' expression+=Expression)* precision=OptDecimalPrecision?;
		@Override public ParserRule getRule() { return rule; }
		
		//expression+=Expression (',' expression+=Expression)* precision=OptDecimalPrecision?
		public Group getGroup() { return cGroup; }
		
		//expression+=Expression
		public Assignment getExpressionAssignment_0() { return cExpressionAssignment_0; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_0_0() { return cExpressionExpressionParserRuleCall_0_0; }
		
		//(',' expression+=Expression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//expression+=Expression
		public Assignment getExpressionAssignment_1_1() { return cExpressionAssignment_1_1; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_1_0() { return cExpressionExpressionParserRuleCall_1_1_0; }
		
		//precision=OptDecimalPrecision?
		public Assignment getPrecisionAssignment_2() { return cPrecisionAssignment_2; }
		
		//OptDecimalPrecision
		public RuleCall getPrecisionOptDecimalPrecisionParserRuleCall_2_0() { return cPrecisionOptDecimalPrecisionParserRuleCall_2_0; }
	}
	public class OptDecimalPrecisionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.OptDecimalPrecision");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFirstPrecisionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFirstPrecisionINTTerminalRuleCall_1_0 = (RuleCall)cFirstPrecisionAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cSecondPrecisionAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cSecondPrecisionINTTerminalRuleCall_2_1_0 = (RuleCall)cSecondPrecisionAssignment_2_1.eContents().get(0);
		
		//OptDecimalPrecision:
		//	':' firstPrecision=INT (':' secondPrecision=INT)?;
		@Override public ParserRule getRule() { return rule; }
		
		//':' firstPrecision=INT (':' secondPrecision=INT)?
		public Group getGroup() { return cGroup; }
		
		//':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//firstPrecision=INT
		public Assignment getFirstPrecisionAssignment_1() { return cFirstPrecisionAssignment_1; }
		
		//INT
		public RuleCall getFirstPrecisionINTTerminalRuleCall_1_0() { return cFirstPrecisionINTTerminalRuleCall_1_0; }
		
		//(':' secondPrecision=INT)?
		public Group getGroup_2() { return cGroup_2; }
		
		//':'
		public Keyword getColonKeyword_2_0() { return cColonKeyword_2_0; }
		
		//secondPrecision=INT
		public Assignment getSecondPrecisionAssignment_2_1() { return cSecondPrecisionAssignment_2_1; }
		
		//INT
		public RuleCall getSecondPrecisionINTTerminalRuleCall_2_1_0() { return cSecondPrecisionINTTerminalRuleCall_2_1_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Expression");
		private final RuleCall cAssignmentParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression:
		//	Assignment;
		@Override public ParserRule getRule() { return rule; }
		
		//Assignment
		public RuleCall getAssignmentParserRuleCall() { return cAssignmentParserRuleCall; }
	}
	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Assignment");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cAssignmentAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cTargetAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final CrossReference cTargetVarNameCrossReference_0_1_0 = (CrossReference)cTargetAssignment_0_1.eContents().get(0);
		private final RuleCall cTargetVarNameIDTerminalRuleCall_0_1_0_1 = (RuleCall)cTargetVarNameCrossReference_0_1_0.eContents().get(1);
		private final Keyword cLessThanSignHyphenMinusKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cValueAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cValueAssignmentParserRuleCall_0_3_0 = (RuleCall)cValueAssignment_0_3.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cOrExpressionParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Group cGroup_1_1_0 = (Group)cGroup_1_1.eContents().get(0);
		private final Group cGroup_1_1_0_0 = (Group)cGroup_1_1_0.eContents().get(0);
		private final Action cBinaryOperationLeftAction_1_1_0_0_0 = (Action)cGroup_1_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_1_0_0_1 = (Assignment)cGroup_1_1_0_0.eContents().get(1);
		private final Keyword cOpLessThanSignHyphenMinusKeyword_1_1_0_0_1_0 = (Keyword)cOpAssignment_1_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cRightAssignmentParserRuleCall_1_1_1_0 = (RuleCall)cRightAssignment_1_1_1.eContents().get(0);
		
		//Assignment Expression:
		//	{Assignment} target=[VarName] '<-' value=Assignment
		//	| OrExpression (=> ({BinaryOperation.left=current} op='<-') right=Assignment)?
		@Override public ParserRule getRule() { return rule; }
		
		//{Assignment} target=[VarName] '<-' value=Assignment | OrExpression (=> ({BinaryOperation.left=current} op='<-')
		//right=Assignment)?
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{Assignment} target=[VarName] '<-' value=Assignment
		public Group getGroup_0() { return cGroup_0; }
		
		//{Assignment}
		public Action getAssignmentAction_0_0() { return cAssignmentAction_0_0; }
		
		//target=[VarName]
		public Assignment getTargetAssignment_0_1() { return cTargetAssignment_0_1; }
		
		//[VarName]
		public CrossReference getTargetVarNameCrossReference_0_1_0() { return cTargetVarNameCrossReference_0_1_0; }
		
		//ID
		public RuleCall getTargetVarNameIDTerminalRuleCall_0_1_0_1() { return cTargetVarNameIDTerminalRuleCall_0_1_0_1; }
		
		//'<-'
		public Keyword getLessThanSignHyphenMinusKeyword_0_2() { return cLessThanSignHyphenMinusKeyword_0_2; }
		
		//value=Assignment
		public Assignment getValueAssignment_0_3() { return cValueAssignment_0_3; }
		
		//Assignment
		public RuleCall getValueAssignmentParserRuleCall_0_3_0() { return cValueAssignmentParserRuleCall_0_3_0; }
		
		//OrExpression (=> ({BinaryOperation.left=current} op='<-') right=Assignment)?
		public Group getGroup_1() { return cGroup_1; }
		
		//OrExpression
		public RuleCall getOrExpressionParserRuleCall_1_0() { return cOrExpressionParserRuleCall_1_0; }
		
		//(=> ({BinaryOperation.left=current} op='<-') right=Assignment)?
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//=> ({BinaryOperation.left=current} op='<-')
		public Group getGroup_1_1_0() { return cGroup_1_1_0; }
		
		//({BinaryOperation.left=current} op='<-')
		public Group getGroup_1_1_0_0() { return cGroup_1_1_0_0; }
		
		//{BinaryOperation.left=current}
		public Action getBinaryOperationLeftAction_1_1_0_0_0() { return cBinaryOperationLeftAction_1_1_0_0_0; }
		
		//op='<-'
		public Assignment getOpAssignment_1_1_0_0_1() { return cOpAssignment_1_1_0_0_1; }
		
		//'<-'
		public Keyword getOpLessThanSignHyphenMinusKeyword_1_1_0_0_1_0() { return cOpLessThanSignHyphenMinusKeyword_1_1_0_0_1_0; }
		
		//right=Assignment
		public Assignment getRightAssignment_1_1_1() { return cRightAssignment_1_1_1; }
		
		//Assignment
		public RuleCall getRightAssignmentParserRuleCall_1_1_1_0() { return cRightAssignmentParserRuleCall_1_1_1_0; }
	}
	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXorExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cBinaryOperationLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Keyword cOpOUKeyword_1_0_0_1_0 = (Keyword)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightXorExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//OrExpression Expression:
		//	XorExpression (=> ({BinaryOperation.left=current} op="OU") right=XorExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//XorExpression (=> ({BinaryOperation.left=current} op="OU") right=XorExpression)*
		public Group getGroup() { return cGroup; }
		
		//XorExpression
		public RuleCall getXorExpressionParserRuleCall_0() { return cXorExpressionParserRuleCall_0; }
		
		//(=> ({BinaryOperation.left=current} op="OU") right=XorExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({BinaryOperation.left=current} op="OU")
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({BinaryOperation.left=current} op="OU")
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{BinaryOperation.left=current}
		public Action getBinaryOperationLeftAction_1_0_0_0() { return cBinaryOperationLeftAction_1_0_0_0; }
		
		//op="OU"
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//"OU"
		public Keyword getOpOUKeyword_1_0_0_1_0() { return cOpOUKeyword_1_0_0_1_0; }
		
		//right=XorExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//XorExpression
		public RuleCall getRightXorExpressionParserRuleCall_1_1_0() { return cRightXorExpressionParserRuleCall_1_1_0; }
	}
	public class XorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.XorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cBinaryOperationLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Keyword cOpXOUKeyword_1_0_0_1_0 = (Keyword)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightAndExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//XorExpression Expression:
		//	AndExpression (=> ({BinaryOperation.left=current} op="XOU") right=AndExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//AndExpression (=> ({BinaryOperation.left=current} op="XOU") right=AndExpression)*
		public Group getGroup() { return cGroup; }
		
		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }
		
		//(=> ({BinaryOperation.left=current} op="XOU") right=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({BinaryOperation.left=current} op="XOU")
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({BinaryOperation.left=current} op="XOU")
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{BinaryOperation.left=current}
		public Action getBinaryOperationLeftAction_1_0_0_0() { return cBinaryOperationLeftAction_1_0_0_0; }
		
		//op="XOU"
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//"XOU"
		public Keyword getOpXOUKeyword_1_0_0_1_0() { return cOpXOUKeyword_1_0_0_1_0; }
		
		//right=AndExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//AndExpression
		public RuleCall getRightAndExpressionParserRuleCall_1_1_0() { return cRightAndExpressionParserRuleCall_1_1_0; }
	}
	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cBinaryOperationLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Alternatives cOpAlternatives_1_0_0_1_0 = (Alternatives)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Keyword cOpAmpersandKeyword_1_0_0_1_0_0 = (Keyword)cOpAlternatives_1_0_0_1_0.eContents().get(0);
		private final Keyword cOpEKeyword_1_0_0_1_0_1 = (Keyword)cOpAlternatives_1_0_0_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightComparisonParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//AndExpression Expression:
		//	Comparison (=> ({BinaryOperation.left=current} op=('&' | 'E')) right=Comparison)*
		@Override public ParserRule getRule() { return rule; }
		
		//Comparison (=> ({BinaryOperation.left=current} op=('&' | 'E')) right=Comparison)*
		public Group getGroup() { return cGroup; }
		
		//Comparison
		public RuleCall getComparisonParserRuleCall_0() { return cComparisonParserRuleCall_0; }
		
		//(=> ({BinaryOperation.left=current} op=('&' | 'E')) right=Comparison)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({BinaryOperation.left=current} op=('&' | 'E'))
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({BinaryOperation.left=current} op=('&' | 'E'))
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{BinaryOperation.left=current}
		public Action getBinaryOperationLeftAction_1_0_0_0() { return cBinaryOperationLeftAction_1_0_0_0; }
		
		//op=('&' | 'E')
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//('&' | 'E')
		public Alternatives getOpAlternatives_1_0_0_1_0() { return cOpAlternatives_1_0_0_1_0; }
		
		//'&'
		public Keyword getOpAmpersandKeyword_1_0_0_1_0_0() { return cOpAmpersandKeyword_1_0_0_1_0_0; }
		
		//'E'
		public Keyword getOpEKeyword_1_0_0_1_0_1() { return cOpEKeyword_1_0_0_1_0_1; }
		
		//right=Comparison
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//Comparison
		public RuleCall getRightComparisonParserRuleCall_1_1_0() { return cRightComparisonParserRuleCall_1_1_0; }
	}
	public class ComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Comparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEquExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cBinaryOperationLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Alternatives cOpAlternatives_1_0_0_1_0 = (Alternatives)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Keyword cOpEqualsSignKeyword_1_0_0_1_0_0 = (Keyword)cOpAlternatives_1_0_0_1_0.eContents().get(0);
		private final Keyword cOpLessThanSignGreaterThanSignKeyword_1_0_0_1_0_1 = (Keyword)cOpAlternatives_1_0_0_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightEquExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Comparison Expression:
		//	EquExpression (=> ({BinaryOperation.left=current} op=('=' | '<>')) right=EquExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//EquExpression (=> ({BinaryOperation.left=current} op=('=' | '<>')) right=EquExpression)*
		public Group getGroup() { return cGroup; }
		
		//EquExpression
		public RuleCall getEquExpressionParserRuleCall_0() { return cEquExpressionParserRuleCall_0; }
		
		//(=> ({BinaryOperation.left=current} op=('=' | '<>')) right=EquExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({BinaryOperation.left=current} op=('=' | '<>'))
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({BinaryOperation.left=current} op=('=' | '<>'))
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{BinaryOperation.left=current}
		public Action getBinaryOperationLeftAction_1_0_0_0() { return cBinaryOperationLeftAction_1_0_0_0; }
		
		//op=('=' | '<>')
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//('=' | '<>')
		public Alternatives getOpAlternatives_1_0_0_1_0() { return cOpAlternatives_1_0_0_1_0; }
		
		//'='
		public Keyword getOpEqualsSignKeyword_1_0_0_1_0_0() { return cOpEqualsSignKeyword_1_0_0_1_0_0; }
		
		//'<>'
		public Keyword getOpLessThanSignGreaterThanSignKeyword_1_0_0_1_0_1() { return cOpLessThanSignGreaterThanSignKeyword_1_0_0_1_0_1; }
		
		//right=EquExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//EquExpression
		public RuleCall getRightEquExpressionParserRuleCall_1_1_0() { return cRightEquExpressionParserRuleCall_1_1_0; }
	}
	public class EquExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.EquExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAddExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cBinaryOperationLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Alternatives cOpAlternatives_1_0_0_1_0 = (Alternatives)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Keyword cOpLessThanSignKeyword_1_0_0_1_0_0 = (Keyword)cOpAlternatives_1_0_0_1_0.eContents().get(0);
		private final Keyword cOpGreaterThanSignKeyword_1_0_0_1_0_1 = (Keyword)cOpAlternatives_1_0_0_1_0.eContents().get(1);
		private final Keyword cOpLessThanSignEqualsSignKeyword_1_0_0_1_0_2 = (Keyword)cOpAlternatives_1_0_0_1_0.eContents().get(2);
		private final Keyword cOpGreaterThanSignEqualsSignKeyword_1_0_0_1_0_3 = (Keyword)cOpAlternatives_1_0_0_1_0.eContents().get(3);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightAddExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//EquExpression Expression:
		//	AddExpression (=> ({BinaryOperation.left=current} op=('<' | '>' | '<=' | '>=')) right=AddExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//AddExpression (=> ({BinaryOperation.left=current} op=('<' | '>' | '<=' | '>=')) right=AddExpression)*
		public Group getGroup() { return cGroup; }
		
		//AddExpression
		public RuleCall getAddExpressionParserRuleCall_0() { return cAddExpressionParserRuleCall_0; }
		
		//(=> ({BinaryOperation.left=current} op=('<' | '>' | '<=' | '>=')) right=AddExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({BinaryOperation.left=current} op=('<' | '>' | '<=' | '>='))
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({BinaryOperation.left=current} op=('<' | '>' | '<=' | '>='))
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{BinaryOperation.left=current}
		public Action getBinaryOperationLeftAction_1_0_0_0() { return cBinaryOperationLeftAction_1_0_0_0; }
		
		//op=('<' | '>' | '<=' | '>=')
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//('<' | '>' | '<=' | '>=')
		public Alternatives getOpAlternatives_1_0_0_1_0() { return cOpAlternatives_1_0_0_1_0; }
		
		//'<'
		public Keyword getOpLessThanSignKeyword_1_0_0_1_0_0() { return cOpLessThanSignKeyword_1_0_0_1_0_0; }
		
		//'>'
		public Keyword getOpGreaterThanSignKeyword_1_0_0_1_0_1() { return cOpGreaterThanSignKeyword_1_0_0_1_0_1; }
		
		//'<='
		public Keyword getOpLessThanSignEqualsSignKeyword_1_0_0_1_0_2() { return cOpLessThanSignEqualsSignKeyword_1_0_0_1_0_2; }
		
		//'>='
		public Keyword getOpGreaterThanSignEqualsSignKeyword_1_0_0_1_0_3() { return cOpGreaterThanSignEqualsSignKeyword_1_0_0_1_0_3; }
		
		//right=AddExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//AddExpression
		public RuleCall getRightAddExpressionParserRuleCall_1_1_0() { return cRightAddExpressionParserRuleCall_1_1_0; }
	}
	public class AddExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.AddExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicativeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cBinaryOperationLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Alternatives cOpAlternatives_1_0_0_1_0 = (Alternatives)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Keyword cOpPlusSignKeyword_1_0_0_1_0_0 = (Keyword)cOpAlternatives_1_0_0_1_0.eContents().get(0);
		private final Keyword cOpHyphenMinusKeyword_1_0_0_1_0_1 = (Keyword)cOpAlternatives_1_0_0_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightMultiplicativeExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//AddExpression Expression:
		//	MultiplicativeExpression (=> ({BinaryOperation.left=current} op=('+' | '-')) right=MultiplicativeExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//MultiplicativeExpression (=> ({BinaryOperation.left=current} op=('+' | '-')) right=MultiplicativeExpression)*
		public Group getGroup() { return cGroup; }
		
		//MultiplicativeExpression
		public RuleCall getMultiplicativeExpressionParserRuleCall_0() { return cMultiplicativeExpressionParserRuleCall_0; }
		
		//(=> ({BinaryOperation.left=current} op=('+' | '-')) right=MultiplicativeExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({BinaryOperation.left=current} op=('+' | '-'))
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({BinaryOperation.left=current} op=('+' | '-'))
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{BinaryOperation.left=current}
		public Action getBinaryOperationLeftAction_1_0_0_0() { return cBinaryOperationLeftAction_1_0_0_0; }
		
		//op=('+' | '-')
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//('+' | '-')
		public Alternatives getOpAlternatives_1_0_0_1_0() { return cOpAlternatives_1_0_0_1_0; }
		
		//'+'
		public Keyword getOpPlusSignKeyword_1_0_0_1_0_0() { return cOpPlusSignKeyword_1_0_0_1_0_0; }
		
		//'-'
		public Keyword getOpHyphenMinusKeyword_1_0_0_1_0_1() { return cOpHyphenMinusKeyword_1_0_0_1_0_1; }
		
		//right=MultiplicativeExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//MultiplicativeExpression
		public RuleCall getRightMultiplicativeExpressionParserRuleCall_1_1_0() { return cRightMultiplicativeExpressionParserRuleCall_1_1_0; }
	}
	public class MultiplicativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.MultiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPowerExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cBinaryOperationLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Alternatives cOpAlternatives_1_0_0_1_0 = (Alternatives)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Keyword cOpAsteriskKeyword_1_0_0_1_0_0 = (Keyword)cOpAlternatives_1_0_0_1_0.eContents().get(0);
		private final Keyword cOpSolidusKeyword_1_0_0_1_0_1 = (Keyword)cOpAlternatives_1_0_0_1_0.eContents().get(1);
		private final Keyword cOpMODKeyword_1_0_0_1_0_2 = (Keyword)cOpAlternatives_1_0_0_1_0.eContents().get(2);
		private final Keyword cOpPercentSignKeyword_1_0_0_1_0_3 = (Keyword)cOpAlternatives_1_0_0_1_0.eContents().get(3);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightPowerExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//MultiplicativeExpression Expression:
		//	PowerExpression (=> ({BinaryOperation.left=current} op=('*' | '/' | 'MOD' | '%')) right=PowerExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//PowerExpression (=> ({BinaryOperation.left=current} op=('*' | '/' | 'MOD' | '%')) right=PowerExpression)*
		public Group getGroup() { return cGroup; }
		
		//PowerExpression
		public RuleCall getPowerExpressionParserRuleCall_0() { return cPowerExpressionParserRuleCall_0; }
		
		//(=> ({BinaryOperation.left=current} op=('*' | '/' | 'MOD' | '%')) right=PowerExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({BinaryOperation.left=current} op=('*' | '/' | 'MOD' | '%'))
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({BinaryOperation.left=current} op=('*' | '/' | 'MOD' | '%'))
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{BinaryOperation.left=current}
		public Action getBinaryOperationLeftAction_1_0_0_0() { return cBinaryOperationLeftAction_1_0_0_0; }
		
		//op=('*' | '/' | 'MOD' | '%')
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//('*' | '/' | 'MOD' | '%')
		public Alternatives getOpAlternatives_1_0_0_1_0() { return cOpAlternatives_1_0_0_1_0; }
		
		//'*'
		public Keyword getOpAsteriskKeyword_1_0_0_1_0_0() { return cOpAsteriskKeyword_1_0_0_1_0_0; }
		
		//'/'
		public Keyword getOpSolidusKeyword_1_0_0_1_0_1() { return cOpSolidusKeyword_1_0_0_1_0_1; }
		
		//'MOD'
		public Keyword getOpMODKeyword_1_0_0_1_0_2() { return cOpMODKeyword_1_0_0_1_0_2; }
		
		//'%'
		public Keyword getOpPercentSignKeyword_1_0_0_1_0_3() { return cOpPercentSignKeyword_1_0_0_1_0_3; }
		
		//right=PowerExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//PowerExpression
		public RuleCall getRightPowerExpressionParserRuleCall_1_1_0() { return cRightPowerExpressionParserRuleCall_1_1_0; }
	}
	public class PowerExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.PowerExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cBinaryOperationLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Keyword cOpCircumflexAccentKeyword_1_0_0_1_0 = (Keyword)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightUnaryExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//PowerExpression Expression:
		//	UnaryExpression (=> ({BinaryOperation.left=current} op='^') right=UnaryExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//UnaryExpression (=> ({BinaryOperation.left=current} op='^') right=UnaryExpression)*
		public Group getGroup() { return cGroup; }
		
		//UnaryExpression
		public RuleCall getUnaryExpressionParserRuleCall_0() { return cUnaryExpressionParserRuleCall_0; }
		
		//(=> ({BinaryOperation.left=current} op='^') right=UnaryExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({BinaryOperation.left=current} op='^')
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({BinaryOperation.left=current} op='^')
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{BinaryOperation.left=current}
		public Action getBinaryOperationLeftAction_1_0_0_0() { return cBinaryOperationLeftAction_1_0_0_0; }
		
		//op='^'
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }
		
		//'^'
		public Keyword getOpCircumflexAccentKeyword_1_0_0_1_0() { return cOpCircumflexAccentKeyword_1_0_0_1_0; }
		
		//right=UnaryExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//UnaryExpression
		public RuleCall getRightUnaryExpressionParserRuleCall_1_1_0() { return cRightUnaryExpressionParserRuleCall_1_1_0; }
	}
	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.UnaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cUnaryExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cOpAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Alternatives cOpAlternatives_0_1_0 = (Alternatives)cOpAssignment_0_1.eContents().get(0);
		private final Keyword cOpNOTKeyword_0_1_0_0 = (Keyword)cOpAlternatives_0_1_0.eContents().get(0);
		private final Keyword cOpHyphenMinusKeyword_0_1_0_1 = (Keyword)cOpAlternatives_0_1_0.eContents().get(1);
		private final Assignment cOperandAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cOperandUnaryExpressionParserRuleCall_0_2_0 = (RuleCall)cOperandAssignment_0_2.eContents().get(0);
		private final RuleCall cMemberCallParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//UnaryExpression Expression:
		//	{UnaryExpression} op=('NOT' | '-') operand=UnaryExpression / * right associativity * /
		//	| MemberCall
		@Override public ParserRule getRule() { return rule; }
		
		//{UnaryExpression} op=('NOT' | '-') operand=UnaryExpression / * right associativity * / | MemberCall
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{UnaryExpression} op=('NOT' | '-') operand=UnaryExpression
		public Group getGroup_0() { return cGroup_0; }
		
		//{UnaryExpression}
		public Action getUnaryExpressionAction_0_0() { return cUnaryExpressionAction_0_0; }
		
		//op=('NOT' | '-')
		public Assignment getOpAssignment_0_1() { return cOpAssignment_0_1; }
		
		//('NOT' | '-')
		public Alternatives getOpAlternatives_0_1_0() { return cOpAlternatives_0_1_0; }
		
		//'NOT'
		public Keyword getOpNOTKeyword_0_1_0_0() { return cOpNOTKeyword_0_1_0_0; }
		
		//'-'
		public Keyword getOpHyphenMinusKeyword_0_1_0_1() { return cOpHyphenMinusKeyword_0_1_0_1; }
		
		//operand=UnaryExpression
		public Assignment getOperandAssignment_0_2() { return cOperandAssignment_0_2; }
		
		//UnaryExpression
		public RuleCall getOperandUnaryExpressionParserRuleCall_0_2_0() { return cOperandUnaryExpressionParserRuleCall_0_2_0; }
		
		//MemberCall
		public RuleCall getMemberCallParserRuleCall_1() { return cMemberCallParserRuleCall_1; }
	}
	public class MemberCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.MemberCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cAssignmentAssignableAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cFeatureAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final CrossReference cFeatureVarNameCrossReference_1_0_0_1_0 = (CrossReference)cFeatureAssignment_1_0_0_1.eContents().get(0);
		private final RuleCall cFeatureVarNameIDTerminalRuleCall_1_0_0_1_0_1 = (RuleCall)cFeatureVarNameCrossReference_1_0_0_1_0.eContents().get(1);
		private final Keyword cLessThanSignHyphenMinusKeyword_1_0_0_2 = (Keyword)cGroup_1_0_0.eContents().get(2);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueAssignmentParserRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		
		//MemberCall Expression:
		//	PrimaryExpression (=> ({Assignment.assignable=current} feature=[VarName] '<-') value=Assignment)*
		@Override public ParserRule getRule() { return rule; }
		
		//PrimaryExpression (=> ({Assignment.assignable=current} feature=[VarName] '<-') value=Assignment)*
		public Group getGroup() { return cGroup; }
		
		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0() { return cPrimaryExpressionParserRuleCall_0; }
		
		//(=> ({Assignment.assignable=current} feature=[VarName] '<-') value=Assignment)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({Assignment.assignable=current} feature=[VarName] '<-')
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//({Assignment.assignable=current} feature=[VarName] '<-')
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{Assignment.assignable=current}
		public Action getAssignmentAssignableAction_1_0_0_0() { return cAssignmentAssignableAction_1_0_0_0; }
		
		//feature=[VarName]
		public Assignment getFeatureAssignment_1_0_0_1() { return cFeatureAssignment_1_0_0_1; }
		
		//[VarName]
		public CrossReference getFeatureVarNameCrossReference_1_0_0_1_0() { return cFeatureVarNameCrossReference_1_0_0_1_0; }
		
		//ID
		public RuleCall getFeatureVarNameIDTerminalRuleCall_1_0_0_1_0_1() { return cFeatureVarNameIDTerminalRuleCall_1_0_0_1_0_1; }
		
		//'<-'
		public Keyword getLessThanSignHyphenMinusKeyword_1_0_0_2() { return cLessThanSignHyphenMinusKeyword_1_0_0_2; }
		
		//value=Assignment
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//Assignment
		public RuleCall getValueAssignmentParserRuleCall_1_1_0() { return cValueAssignmentParserRuleCall_1_1_0; }
	}
	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFunctionCallParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//PrimaryExpression Expression:
		//	Literal
		//	| FunctionCall
		//	| '(' Expression ')'
		@Override public ParserRule getRule() { return rule; }
		
		//Literal | FunctionCall | '(' Expression ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Literal
		public RuleCall getLiteralParserRuleCall_0() { return cLiteralParserRuleCall_0; }
		
		//FunctionCall
		public RuleCall getFunctionCallParserRuleCall_1() { return cFunctionCallParserRuleCall_1; }
		
		//'(' Expression ')'
		public Group getGroup_2() { return cGroup_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_2_1() { return cExpressionParserRuleCall_2_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
	}
	public class FunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.FunctionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFbNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cFbNameFunctionNameCrossReference_0_0 = (CrossReference)cFbNameAssignment_0.eContents().get(0);
		private final RuleCall cFbNameFunctionNameIDTerminalRuleCall_0_0_1 = (RuleCall)cFbNameFunctionNameCrossReference_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParamAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParamWriteParamParserRuleCall_2_0 = (RuleCall)cParamAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//FunctionCall Expression:
		//	fbName=[FunctionName] '(' param=WriteParam ')'
		@Override public ParserRule getRule() { return rule; }
		
		//fbName=[FunctionName] '(' param=WriteParam ')'
		public Group getGroup() { return cGroup; }
		
		//fbName=[FunctionName]
		public Assignment getFbNameAssignment_0() { return cFbNameAssignment_0; }
		
		//[FunctionName]
		public CrossReference getFbNameFunctionNameCrossReference_0_0() { return cFbNameFunctionNameCrossReference_0_0; }
		
		//ID
		public RuleCall getFbNameFunctionNameIDTerminalRuleCall_0_0_1() { return cFbNameFunctionNameIDTerminalRuleCall_0_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//param=WriteParam
		public Assignment getParamAssignment_2() { return cParamAssignment_2; }
		
		//WriteParam
		public RuleCall getParamWriteParamParserRuleCall_2_0() { return cParamWriteParamParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class ProcedureCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.ProcedureCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFbNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cFbNameProcedureNameCrossReference_0_0 = (CrossReference)cFbNameAssignment_0.eContents().get(0);
		private final RuleCall cFbNameProcedureNameIDTerminalRuleCall_0_0_1 = (RuleCall)cFbNameProcedureNameCrossReference_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParamAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParamWriteParamParserRuleCall_2_0 = (RuleCall)cParamAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ProcedureCall Expression:
		//	fbName=[ProcedureName] '(' param=WriteParam ')'
		@Override public ParserRule getRule() { return rule; }
		
		//fbName=[ProcedureName] '(' param=WriteParam ')'
		public Group getGroup() { return cGroup; }
		
		//fbName=[ProcedureName]
		public Assignment getFbNameAssignment_0() { return cFbNameAssignment_0; }
		
		//[ProcedureName]
		public CrossReference getFbNameProcedureNameCrossReference_0_0() { return cFbNameProcedureNameCrossReference_0_0; }
		
		//ID
		public RuleCall getFbNameProcedureNameIDTerminalRuleCall_0_0_1() { return cFbNameProcedureNameIDTerminalRuleCall_0_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//param=WriteParam
		public Assignment getParamAssignment_2() { return cParamAssignment_2; }
		
		//WriteParam
		public RuleCall getParamWriteParamParserRuleCall_2_0() { return cParamWriteParamParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumericLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Literal Expression:
		//	NumericLiteral | StringExpression
		@Override public ParserRule getRule() { return rule; }
		
		//NumericLiteral | StringExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//NumericLiteral
		public RuleCall getNumericLiteralParserRuleCall_0() { return cNumericLiteralParserRuleCall_0; }
		
		//StringExpression
		public RuleCall getStringExpressionParserRuleCall_1() { return cStringExpressionParserRuleCall_1; }
	}
	public class NumericLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.NumericLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cIntValueAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cIntValueINTTerminalRuleCall_0_0 = (RuleCall)cIntValueAssignment_0.eContents().get(0);
		private final Assignment cFloatValueAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cFloatValueFLOATTerminalRuleCall_1_0 = (RuleCall)cFloatValueAssignment_1.eContents().get(0);
		
		//NumericLiteral:
		//	intValue?=INT
		//	| floatValue?=FLOAT;
		@Override public ParserRule getRule() { return rule; }
		
		//intValue?=INT | floatValue?=FLOAT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//intValue?=INT
		public Assignment getIntValueAssignment_0() { return cIntValueAssignment_0; }
		
		//INT
		public RuleCall getIntValueINTTerminalRuleCall_0_0() { return cIntValueINTTerminalRuleCall_0_0; }
		
		//floatValue?=FLOAT
		public Assignment getFloatValueAssignment_1() { return cFloatValueAssignment_1; }
		
		//FLOAT
		public RuleCall getFloatValueFLOATTerminalRuleCall_1_0() { return cFloatValueFLOATTerminalRuleCall_1_0; }
	}
	public class StringExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.StringExpression");
		private final Assignment cLiteralStringAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cLiteralStringSTRINGTerminalRuleCall_0 = (RuleCall)cLiteralStringAssignment.eContents().get(0);
		
		//StringExpression:
		//	literalString=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//literalString=STRING
		public Assignment getLiteralStringAssignment() { return cLiteralStringAssignment; }
		
		//STRING
		public RuleCall getLiteralStringSTRINGTerminalRuleCall_0() { return cLiteralStringSTRINGTerminalRuleCall_0; }
	}
	
	
	private final ModelElements pModel;
	private final HeaderBlockElements pHeaderBlock;
	private final DeclarationsBlockElements pDeclarationsBlock;
	private final VariableElements pVariable;
	private final VarDeclarationElements pVarDeclaration;
	private final DeclaredVarElements pDeclaredVar;
	private final VarNameElements pVarName;
	private final VarTypeElements pVarType;
	private final SubprogramsElements pSubprograms;
	private final BlockSubProgramsElements pBlockSubPrograms;
	private final FunctionNameElements pFunctionName;
	private final ProcedureNameElements pProcedureName;
	private final BlockFunctionElements pBlockFunction;
	private final BlockProcedureElements pBlockProcedure;
	private final BlockCommandElements pBlockCommand;
	private final AbstractCommandElements pAbstractCommand;
	private final ReadCommandElements pReadCommand;
	private final WriteCommandElements pWriteCommand;
	private final WriteParamElements pWriteParam;
	private final OptDecimalPrecisionElements pOptDecimalPrecision;
	private final ExpressionElements pExpression;
	private final AssignmentElements pAssignment;
	private final OrExpressionElements pOrExpression;
	private final XorExpressionElements pXorExpression;
	private final AndExpressionElements pAndExpression;
	private final ComparisonElements pComparison;
	private final EquExpressionElements pEquExpression;
	private final AddExpressionElements pAddExpression;
	private final MultiplicativeExpressionElements pMultiplicativeExpression;
	private final PowerExpressionElements pPowerExpression;
	private final UnaryExpressionElements pUnaryExpression;
	private final MemberCallElements pMemberCall;
	private final PrimaryExpressionElements pPrimaryExpression;
	private final FunctionCallElements pFunctionCall;
	private final ProcedureCallElements pProcedureCall;
	private final LiteralElements pLiteral;
	private final NumericLiteralElements pNumericLiteral;
	private final StringExpressionElements pStringExpression;
	private final TerminalRule tFLOAT;
	private final TerminalRule tEND_COMMAND;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public PortugolGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pHeaderBlock = new HeaderBlockElements();
		this.pDeclarationsBlock = new DeclarationsBlockElements();
		this.pVariable = new VariableElements();
		this.pVarDeclaration = new VarDeclarationElements();
		this.pDeclaredVar = new DeclaredVarElements();
		this.pVarName = new VarNameElements();
		this.pVarType = new VarTypeElements();
		this.pSubprograms = new SubprogramsElements();
		this.pBlockSubPrograms = new BlockSubProgramsElements();
		this.pFunctionName = new FunctionNameElements();
		this.pProcedureName = new ProcedureNameElements();
		this.pBlockFunction = new BlockFunctionElements();
		this.pBlockProcedure = new BlockProcedureElements();
		this.pBlockCommand = new BlockCommandElements();
		this.pAbstractCommand = new AbstractCommandElements();
		this.pReadCommand = new ReadCommandElements();
		this.pWriteCommand = new WriteCommandElements();
		this.pWriteParam = new WriteParamElements();
		this.pOptDecimalPrecision = new OptDecimalPrecisionElements();
		this.pExpression = new ExpressionElements();
		this.pAssignment = new AssignmentElements();
		this.pOrExpression = new OrExpressionElements();
		this.pXorExpression = new XorExpressionElements();
		this.pAndExpression = new AndExpressionElements();
		this.pComparison = new ComparisonElements();
		this.pEquExpression = new EquExpressionElements();
		this.pAddExpression = new AddExpressionElements();
		this.pMultiplicativeExpression = new MultiplicativeExpressionElements();
		this.pPowerExpression = new PowerExpressionElements();
		this.pUnaryExpression = new UnaryExpressionElements();
		this.pMemberCall = new MemberCallElements();
		this.pPrimaryExpression = new PrimaryExpressionElements();
		this.pFunctionCall = new FunctionCallElements();
		this.pProcedureCall = new ProcedureCallElements();
		this.pLiteral = new LiteralElements();
		this.pNumericLiteral = new NumericLiteralElements();
		this.pStringExpression = new StringExpressionElements();
		this.tFLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.FLOAT");
		this.tEND_COMMAND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.hopper.language.Portugol.END_COMMAND");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.hopper.language.Portugol".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	header=HeaderBlock
	//	globalDeclarations=DeclarationsBlock
	//	subprograms=Subprograms?
	//	commands=BlockCommand;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	//HeaderBlock:
	//	'algoritmo' name=STRING END_COMMAND;
	public HeaderBlockElements getHeaderBlockAccess() {
		return pHeaderBlock;
	}
	
	public ParserRule getHeaderBlockRule() {
		return getHeaderBlockAccess().getRule();
	}
	
	//DeclarationsBlock:
	//	'var' END_COMMAND (vars+=Variable END_COMMAND)+;
	public DeclarationsBlockElements getDeclarationsBlockAccess() {
		return pDeclarationsBlock;
	}
	
	public ParserRule getDeclarationsBlockRule() {
		return getDeclarationsBlockAccess().getRule();
	}
	
	//Variable:
	//	varDeclaration=VarDeclaration ':' type=VarType;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//VarDeclaration:
	//	vars+=VarName (',' vars+=VarName)*;
	public VarDeclarationElements getVarDeclarationAccess() {
		return pVarDeclaration;
	}
	
	public ParserRule getVarDeclarationRule() {
		return getVarDeclarationAccess().getRule();
	}
	
	//DeclaredVar:
	//	vars+=[VarName] (',' vars+=[VarName])*;
	public DeclaredVarElements getDeclaredVarAccess() {
		return pDeclaredVar;
	}
	
	public ParserRule getDeclaredVarRule() {
		return getDeclaredVarAccess().getRule();
	}
	
	//VarName:
	//	name=ID;
	public VarNameElements getVarNameAccess() {
		return pVarName;
	}
	
	public ParserRule getVarNameRule() {
		return getVarNameAccess().getRule();
	}
	
	//VarType:
	//	typeName=('real' | 'inteiro' | 'caractere');
	public VarTypeElements getVarTypeAccess() {
		return pVarType;
	}
	
	public ParserRule getVarTypeRule() {
		return getVarTypeAccess().getRule();
	}
	
	//Subprograms:
	//	blockSubPrograms+=BlockSubPrograms+;
	public SubprogramsElements getSubprogramsAccess() {
		return pSubprograms;
	}
	
	public ParserRule getSubprogramsRule() {
		return getSubprogramsAccess().getRule();
	}
	
	//BlockSubPrograms:
	//	BlockFunction | BlockProcedure;
	public BlockSubProgramsElements getBlockSubProgramsAccess() {
		return pBlockSubPrograms;
	}
	
	public ParserRule getBlockSubProgramsRule() {
		return getBlockSubProgramsAccess().getRule();
	}
	
	//FunctionName:
	//	name=ID;
	public FunctionNameElements getFunctionNameAccess() {
		return pFunctionName;
	}
	
	public ParserRule getFunctionNameRule() {
		return getFunctionNameAccess().getRule();
	}
	
	//ProcedureName:
	//	name=ID;
	public ProcedureNameElements getProcedureNameAccess() {
		return pProcedureName;
	}
	
	public ParserRule getProcedureNameRule() {
		return getProcedureNameAccess().getRule();
	}
	
	//BlockFunction:
	//	'funcao' functionName=FunctionName '(' paramList=Variable ')' ':' returnType=VarType END_COMMAND
	//	declarations=DeclarationsBlock?
	//	'inicio' END_COMMAND
	//	commands+=AbstractCommand+
	//	'fimfuncao' END_COMMAND;
	public BlockFunctionElements getBlockFunctionAccess() {
		return pBlockFunction;
	}
	
	public ParserRule getBlockFunctionRule() {
		return getBlockFunctionAccess().getRule();
	}
	
	//BlockProcedure:
	//	'procedimento' procedure=ProcedureName '(' paramList=Variable ')' END_COMMAND
	//	declarations=DeclarationsBlock?
	//	'inicio' END_COMMAND
	//	commands+=AbstractCommand+
	//	'fimprocedimento' END_COMMAND;
	public BlockProcedureElements getBlockProcedureAccess() {
		return pBlockProcedure;
	}
	
	public ParserRule getBlockProcedureRule() {
		return getBlockProcedureAccess().getRule();
	}
	
	//BlockCommand:
	//	'inicio' END_COMMAND
	//	commands+=AbstractCommand+
	//	'fimalgoritmo' END_COMMAND;
	public BlockCommandElements getBlockCommandAccess() {
		return pBlockCommand;
	}
	
	public ParserRule getBlockCommandRule() {
		return getBlockCommandAccess().getRule();
	}
	
	//AbstractCommand:
	//	ReadCommand END_COMMAND
	//	| WriteCommand END_COMMAND
	//	| Expression END_COMMAND;
	public AbstractCommandElements getAbstractCommandAccess() {
		return pAbstractCommand;
	}
	
	public ParserRule getAbstractCommandRule() {
		return getAbstractCommandAccess().getRule();
	}
	
	//ReadCommand:
	//	'leia' '(' paramList=DeclaredVar ')';
	public ReadCommandElements getReadCommandAccess() {
		return pReadCommand;
	}
	
	public ParserRule getReadCommandRule() {
		return getReadCommandAccess().getRule();
	}
	
	//WriteCommand:
	//	'escreva' '(' writeParam=WriteParam ')';
	public WriteCommandElements getWriteCommandAccess() {
		return pWriteCommand;
	}
	
	public ParserRule getWriteCommandRule() {
		return getWriteCommandAccess().getRule();
	}
	
	//WriteParam:
	//	expression+=Expression (',' expression+=Expression)* precision=OptDecimalPrecision?;
	public WriteParamElements getWriteParamAccess() {
		return pWriteParam;
	}
	
	public ParserRule getWriteParamRule() {
		return getWriteParamAccess().getRule();
	}
	
	//OptDecimalPrecision:
	//	':' firstPrecision=INT (':' secondPrecision=INT)?;
	public OptDecimalPrecisionElements getOptDecimalPrecisionAccess() {
		return pOptDecimalPrecision;
	}
	
	public ParserRule getOptDecimalPrecisionRule() {
		return getOptDecimalPrecisionAccess().getRule();
	}
	
	//Expression:
	//	Assignment;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//Assignment Expression:
	//	{Assignment} target=[VarName] '<-' value=Assignment
	//	| OrExpression (=> ({BinaryOperation.left=current} op='<-') right=Assignment)?
	public AssignmentElements getAssignmentAccess() {
		return pAssignment;
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}
	
	//OrExpression Expression:
	//	XorExpression (=> ({BinaryOperation.left=current} op="OU") right=XorExpression)*
	public OrExpressionElements getOrExpressionAccess() {
		return pOrExpression;
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}
	
	//XorExpression Expression:
	//	AndExpression (=> ({BinaryOperation.left=current} op="XOU") right=AndExpression)*
	public XorExpressionElements getXorExpressionAccess() {
		return pXorExpression;
	}
	
	public ParserRule getXorExpressionRule() {
		return getXorExpressionAccess().getRule();
	}
	
	//AndExpression Expression:
	//	Comparison (=> ({BinaryOperation.left=current} op=('&' | 'E')) right=Comparison)*
	public AndExpressionElements getAndExpressionAccess() {
		return pAndExpression;
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}
	
	//Comparison Expression:
	//	EquExpression (=> ({BinaryOperation.left=current} op=('=' | '<>')) right=EquExpression)*
	public ComparisonElements getComparisonAccess() {
		return pComparison;
	}
	
	public ParserRule getComparisonRule() {
		return getComparisonAccess().getRule();
	}
	
	//EquExpression Expression:
	//	AddExpression (=> ({BinaryOperation.left=current} op=('<' | '>' | '<=' | '>=')) right=AddExpression)*
	public EquExpressionElements getEquExpressionAccess() {
		return pEquExpression;
	}
	
	public ParserRule getEquExpressionRule() {
		return getEquExpressionAccess().getRule();
	}
	
	//AddExpression Expression:
	//	MultiplicativeExpression (=> ({BinaryOperation.left=current} op=('+' | '-')) right=MultiplicativeExpression)*
	public AddExpressionElements getAddExpressionAccess() {
		return pAddExpression;
	}
	
	public ParserRule getAddExpressionRule() {
		return getAddExpressionAccess().getRule();
	}
	
	//MultiplicativeExpression Expression:
	//	PowerExpression (=> ({BinaryOperation.left=current} op=('*' | '/' | 'MOD' | '%')) right=PowerExpression)*
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return pMultiplicativeExpression;
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}
	
	//PowerExpression Expression:
	//	UnaryExpression (=> ({BinaryOperation.left=current} op='^') right=UnaryExpression)*
	public PowerExpressionElements getPowerExpressionAccess() {
		return pPowerExpression;
	}
	
	public ParserRule getPowerExpressionRule() {
		return getPowerExpressionAccess().getRule();
	}
	
	//UnaryExpression Expression:
	//	{UnaryExpression} op=('NOT' | '-') operand=UnaryExpression / * right associativity * /
	//	| MemberCall
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return pUnaryExpression;
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}
	
	//MemberCall Expression:
	//	PrimaryExpression (=> ({Assignment.assignable=current} feature=[VarName] '<-') value=Assignment)*
	public MemberCallElements getMemberCallAccess() {
		return pMemberCall;
	}
	
	public ParserRule getMemberCallRule() {
		return getMemberCallAccess().getRule();
	}
	
	//PrimaryExpression Expression:
	//	Literal
	//	| FunctionCall
	//	| '(' Expression ')'
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return pPrimaryExpression;
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}
	
	//FunctionCall Expression:
	//	fbName=[FunctionName] '(' param=WriteParam ')'
	public FunctionCallElements getFunctionCallAccess() {
		return pFunctionCall;
	}
	
	public ParserRule getFunctionCallRule() {
		return getFunctionCallAccess().getRule();
	}
	
	//ProcedureCall Expression:
	//	fbName=[ProcedureName] '(' param=WriteParam ')'
	public ProcedureCallElements getProcedureCallAccess() {
		return pProcedureCall;
	}
	
	public ParserRule getProcedureCallRule() {
		return getProcedureCallAccess().getRule();
	}
	
	//Literal Expression:
	//	NumericLiteral | StringExpression
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}
	
	//NumericLiteral:
	//	intValue?=INT
	//	| floatValue?=FLOAT;
	public NumericLiteralElements getNumericLiteralAccess() {
		return pNumericLiteral;
	}
	
	public ParserRule getNumericLiteralRule() {
		return getNumericLiteralAccess().getRule();
	}
	
	//StringExpression:
	//	literalString=STRING;
	public StringExpressionElements getStringExpressionAccess() {
		return pStringExpression;
	}
	
	public ParserRule getStringExpressionRule() {
		return getStringExpressionAccess().getRule();
	}
	
	//terminal FLOAT:
	//	INT '.' INT;
	public TerminalRule getFLOATRule() {
		return tFLOAT;
	}
	
	//terminal END_COMMAND:
	//	(' ' | '\t')* ('\r' | '\n')+ (' ' | '\t')*;
	public TerminalRule getEND_COMMANDRule() {
		return tEND_COMMAND;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}

/*
 * generated by Xtext 2.9.0
 */
package org.hopper.language.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.hopper.language.portugol.BinaryOperation;
import org.hopper.language.portugol.BlockCommand;
import org.hopper.language.portugol.BlockFunction;
import org.hopper.language.portugol.BlockProcedure;
import org.hopper.language.portugol.BooleanLiteral;
import org.hopper.language.portugol.BreakStatement;
import org.hopper.language.portugol.CaseList;
import org.hopper.language.portugol.DeclarationsBlock;
import org.hopper.language.portugol.DeclaredVar;
import org.hopper.language.portugol.DeclaredVarList;
import org.hopper.language.portugol.Expression;
import org.hopper.language.portugol.FloatLiteral;
import org.hopper.language.portugol.ForStatement;
import org.hopper.language.portugol.FunctionCall;
import org.hopper.language.portugol.FunctionName;
import org.hopper.language.portugol.HeaderBlock;
import org.hopper.language.portugol.IfStatement;
import org.hopper.language.portugol.IntLiteral;
import org.hopper.language.portugol.Model;
import org.hopper.language.portugol.Operator;
import org.hopper.language.portugol.OptDecimalPrecision;
import org.hopper.language.portugol.OtherCase;
import org.hopper.language.portugol.PiLiteral;
import org.hopper.language.portugol.PortugolPackage;
import org.hopper.language.portugol.ProcedureCall;
import org.hopper.language.portugol.ProcedureName;
import org.hopper.language.portugol.ReadCommand;
import org.hopper.language.portugol.RepeatStatement;
import org.hopper.language.portugol.ReturnStatement;
import org.hopper.language.portugol.StringLiteral;
import org.hopper.language.portugol.SubprogramParam;
import org.hopper.language.portugol.SubprogramParamDeclaration;
import org.hopper.language.portugol.Subprograms;
import org.hopper.language.portugol.SwitchCaseStatement;
import org.hopper.language.portugol.UnaryOperation;
import org.hopper.language.portugol.VarDeclaration;
import org.hopper.language.portugol.VarName;
import org.hopper.language.portugol.VarType;
import org.hopper.language.portugol.Variable;
import org.hopper.language.portugol.WhileStatement;
import org.hopper.language.portugol.WriteCommand;
import org.hopper.language.portugol.WriteParam;
import org.hopper.language.services.PortugolGrammarAccess;

@SuppressWarnings("all")
public class PortugolSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PortugolGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PortugolPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PortugolPackage.BINARY_OPERATION:
				sequence_AddExpression_AndExpression_Assignment_Comparison_EquExpression_MultiplicativeExpression_OrExpression_PowerExpression_XorExpression(context, (BinaryOperation) semanticObject); 
				return; 
			case PortugolPackage.BLOCK_COMMAND:
				sequence_BlockCommand(context, (BlockCommand) semanticObject); 
				return; 
			case PortugolPackage.BLOCK_FUNCTION:
				sequence_BlockFunction(context, (BlockFunction) semanticObject); 
				return; 
			case PortugolPackage.BLOCK_PROCEDURE:
				sequence_BlockProcedure(context, (BlockProcedure) semanticObject); 
				return; 
			case PortugolPackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case PortugolPackage.BREAK_STATEMENT:
				sequence_BreakStatement(context, (BreakStatement) semanticObject); 
				return; 
			case PortugolPackage.CASE_LIST:
				sequence_CaseList(context, (CaseList) semanticObject); 
				return; 
			case PortugolPackage.DECLARATIONS_BLOCK:
				sequence_DeclarationsBlock(context, (DeclarationsBlock) semanticObject); 
				return; 
			case PortugolPackage.DECLARED_VAR:
				sequence_DeclaredVar(context, (DeclaredVar) semanticObject); 
				return; 
			case PortugolPackage.DECLARED_VAR_LIST:
				sequence_DeclaredVarList(context, (DeclaredVarList) semanticObject); 
				return; 
			case PortugolPackage.EXPRESSION:
				sequence_PreDefinedFunctionCall(context, (Expression) semanticObject); 
				return; 
			case PortugolPackage.FLOAT_LITERAL:
				sequence_FloatLiteral(context, (FloatLiteral) semanticObject); 
				return; 
			case PortugolPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case PortugolPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case PortugolPackage.FUNCTION_NAME:
				sequence_FunctionName(context, (FunctionName) semanticObject); 
				return; 
			case PortugolPackage.HEADER_BLOCK:
				sequence_HeaderBlock(context, (HeaderBlock) semanticObject); 
				return; 
			case PortugolPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case PortugolPackage.INT_LITERAL:
				sequence_IntLiteral(context, (IntLiteral) semanticObject); 
				return; 
			case PortugolPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case PortugolPackage.OPERATOR:
				if (rule == grammarAccess.getAddOperatorRule()) {
					sequence_AddOperator(context, (Operator) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAndOperatorRule()) {
					sequence_AndOperator(context, (Operator) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignmentOperatorRule()) {
					sequence_AssignmentOperator(context, (Operator) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getComparisonOperatorRule()) {
					sequence_ComparisonOperator(context, (Operator) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEqualityOperatorRule()) {
					sequence_EqualityOperator(context, (Operator) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMultiplicativeOperatorRule()) {
					sequence_MultiplicativeOperator(context, (Operator) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNotOperatorRule()) {
					sequence_NotOperator(context, (Operator) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOrOperatorRule()) {
					sequence_OrOperator(context, (Operator) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPowerOperatorRule()) {
					sequence_PowerOperator(context, (Operator) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXorOperatorRule()) {
					sequence_XorOperator(context, (Operator) semanticObject); 
					return; 
				}
				else break;
			case PortugolPackage.OPT_DECIMAL_PRECISION:
				sequence_OptDecimalPrecision(context, (OptDecimalPrecision) semanticObject); 
				return; 
			case PortugolPackage.OTHER_CASE:
				sequence_OtherCase(context, (OtherCase) semanticObject); 
				return; 
			case PortugolPackage.PI_LITERAL:
				sequence_PiLiteral(context, (PiLiteral) semanticObject); 
				return; 
			case PortugolPackage.PROCEDURE_CALL:
				sequence_ProcedureCall(context, (ProcedureCall) semanticObject); 
				return; 
			case PortugolPackage.PROCEDURE_NAME:
				sequence_ProcedureName(context, (ProcedureName) semanticObject); 
				return; 
			case PortugolPackage.READ_COMMAND:
				sequence_ReadCommand(context, (ReadCommand) semanticObject); 
				return; 
			case PortugolPackage.REPEAT_STATEMENT:
				sequence_RepeatStatement(context, (RepeatStatement) semanticObject); 
				return; 
			case PortugolPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case PortugolPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case PortugolPackage.SUBPROGRAM_PARAM:
				sequence_SubprogramParam(context, (SubprogramParam) semanticObject); 
				return; 
			case PortugolPackage.SUBPROGRAM_PARAM_DECLARATION:
				sequence_SubprogramParamDeclaration(context, (SubprogramParamDeclaration) semanticObject); 
				return; 
			case PortugolPackage.SUBPROGRAMS:
				sequence_Subprograms(context, (Subprograms) semanticObject); 
				return; 
			case PortugolPackage.SWITCH_CASE_STATEMENT:
				sequence_SwitchCaseStatement(context, (SwitchCaseStatement) semanticObject); 
				return; 
			case PortugolPackage.UNARY_OPERATION:
				sequence_UnaryOperation(context, (UnaryOperation) semanticObject); 
				return; 
			case PortugolPackage.VAR_DECLARATION:
				sequence_VarDeclaration(context, (VarDeclaration) semanticObject); 
				return; 
			case PortugolPackage.VAR_NAME:
				sequence_VarName(context, (VarName) semanticObject); 
				return; 
			case PortugolPackage.VAR_TYPE:
				sequence_VarType(context, (VarType) semanticObject); 
				return; 
			case PortugolPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case PortugolPackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			case PortugolPackage.WRITE_COMMAND:
				sequence_WriteCommand(context, (WriteCommand) semanticObject); 
				return; 
			case PortugolPackage.WRITE_PARAM:
				sequence_WriteParam(context, (WriteParam) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AbstractCommand returns BinaryOperation
	 *     Expression returns BinaryOperation
	 *     Assignment returns BinaryOperation
	 *     Assignment.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *     OrExpression returns BinaryOperation
	 *     OrExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *     XorExpression returns BinaryOperation
	 *     XorExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *     AndExpression returns BinaryOperation
	 *     AndExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *     Comparison returns BinaryOperation
	 *     Comparison.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *     EquExpression returns BinaryOperation
	 *     EquExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *     AddExpression returns BinaryOperation
	 *     AddExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *     MultiplicativeExpression returns BinaryOperation
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *     PowerExpression returns BinaryOperation
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *     UnaryOperation returns BinaryOperation
	 *     PrimaryExpression returns BinaryOperation
	 *
	 * Constraint:
	 *     (
	 *         (left=Assignment_BinaryOperation_1_0_0_0 op=AssignmentOperator right=Assignment) | 
	 *         (left=OrExpression_BinaryOperation_1_0_0_0 op=OrOperator right=XorExpression) | 
	 *         (left=XorExpression_BinaryOperation_1_0_0_0 op=XorOperator right=AndExpression) | 
	 *         (left=AndExpression_BinaryOperation_1_0_0_0 op=AndOperator right=Comparison) | 
	 *         (left=Comparison_BinaryOperation_1_0_0_0 op=ComparisonOperator right=EquExpression) | 
	 *         (left=EquExpression_BinaryOperation_1_0_0_0 op=EqualityOperator right=AddExpression) | 
	 *         (left=AddExpression_BinaryOperation_1_0_0_0 op=AddOperator right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_BinaryOperation_1_0_0_0 op=MultiplicativeOperator right=PowerExpression) | 
	 *         (left=PowerExpression_BinaryOperation_1_0_0_0 op=PowerOperator right=UnaryOperation)
	 *     )
	 */
	protected void sequence_AddExpression_AndExpression_Assignment_Comparison_EquExpression_MultiplicativeExpression_OrExpression_PowerExpression_XorExpression(ISerializationContext context, BinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AddOperator returns Operator
	 *
	 * Constraint:
	 *     (op='+' | op='-')
	 */
	protected void sequence_AddOperator(ISerializationContext context, Operator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AndOperator returns Operator
	 *
	 * Constraint:
	 *     op='E'
	 */
	protected void sequence_AndOperator(ISerializationContext context, Operator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.OPERATOR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.OPERATOR__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndOperatorAccess().getOpEKeyword_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AssignmentOperator returns Operator
	 *
	 * Constraint:
	 *     op='<-'
	 */
	protected void sequence_AssignmentOperator(ISerializationContext context, Operator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.OPERATOR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.OPERATOR__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentOperatorAccess().getOpLessThanSignHyphenMinusKeyword_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockCommand returns BlockCommand
	 *
	 * Constraint:
	 *     commands+=AbstractCommand+
	 */
	protected void sequence_BlockCommand(ISerializationContext context, BlockCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockSubPrograms returns BlockFunction
	 *     BlockFunction returns BlockFunction
	 *
	 * Constraint:
	 *     (functionName=FunctionName params=SubprogramParamDeclaration? returnType=VarType declarations=DeclarationsBlock? commands+=AbstractCommand+)
	 */
	protected void sequence_BlockFunction(ISerializationContext context, BlockFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockSubPrograms returns BlockProcedure
	 *     BlockProcedure returns BlockProcedure
	 *
	 * Constraint:
	 *     (procedureName=ProcedureName params=SubprogramParamDeclaration? declarations=DeclarationsBlock? commands+=AbstractCommand+)
	 */
	protected void sequence_BlockProcedure(ISerializationContext context, BlockProcedure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCommand returns BooleanLiteral
	 *     Expression returns BooleanLiteral
	 *     Assignment returns BooleanLiteral
	 *     Assignment.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     OrExpression returns BooleanLiteral
	 *     OrExpression.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     XorExpression returns BooleanLiteral
	 *     XorExpression.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     AndExpression returns BooleanLiteral
	 *     AndExpression.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     Comparison returns BooleanLiteral
	 *     Comparison.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     EquExpression returns BooleanLiteral
	 *     EquExpression.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     AddExpression returns BooleanLiteral
	 *     AddExpression.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     MultiplicativeExpression returns BooleanLiteral
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     PowerExpression returns BooleanLiteral
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     UnaryOperation returns BooleanLiteral
	 *     PrimaryExpression returns BooleanLiteral
	 *     Literal returns BooleanLiteral
	 *     BooleanLiteral returns BooleanLiteral
	 *
	 * Constraint:
	 *     (value='verdadeiro' | value='falso')
	 */
	protected void sequence_BooleanLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCommand returns BreakStatement
	 *     BreakStatement returns BreakStatement
	 *
	 * Constraint:
	 *     {BreakStatement}
	 */
	protected void sequence_BreakStatement(ISerializationContext context, BreakStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CaseList returns CaseList
	 *
	 * Constraint:
	 *     (expr=Expression commands+=AbstractCommand+)
	 */
	protected void sequence_CaseList(ISerializationContext context, CaseList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComparisonOperator returns Operator
	 *
	 * Constraint:
	 *     (op='=' | op='<>')
	 */
	protected void sequence_ComparisonOperator(ISerializationContext context, Operator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclarationsBlock returns DeclarationsBlock
	 *
	 * Constraint:
	 *     vars+=Variable+
	 */
	protected void sequence_DeclarationsBlock(ISerializationContext context, DeclarationsBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclaredVarList returns DeclaredVarList
	 *
	 * Constraint:
	 *     (vars+=[VarName|ID] vars+=[VarName|ID]*)
	 */
	protected void sequence_DeclaredVarList(ISerializationContext context, DeclaredVarList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCommand returns DeclaredVar
	 *     Expression returns DeclaredVar
	 *     Assignment returns DeclaredVar
	 *     Assignment.BinaryOperation_1_0_0_0 returns DeclaredVar
	 *     OrExpression returns DeclaredVar
	 *     OrExpression.BinaryOperation_1_0_0_0 returns DeclaredVar
	 *     XorExpression returns DeclaredVar
	 *     XorExpression.BinaryOperation_1_0_0_0 returns DeclaredVar
	 *     AndExpression returns DeclaredVar
	 *     AndExpression.BinaryOperation_1_0_0_0 returns DeclaredVar
	 *     Comparison returns DeclaredVar
	 *     Comparison.BinaryOperation_1_0_0_0 returns DeclaredVar
	 *     EquExpression returns DeclaredVar
	 *     EquExpression.BinaryOperation_1_0_0_0 returns DeclaredVar
	 *     AddExpression returns DeclaredVar
	 *     AddExpression.BinaryOperation_1_0_0_0 returns DeclaredVar
	 *     MultiplicativeExpression returns DeclaredVar
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns DeclaredVar
	 *     PowerExpression returns DeclaredVar
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns DeclaredVar
	 *     UnaryOperation returns DeclaredVar
	 *     PrimaryExpression returns DeclaredVar
	 *     DeclaredVar returns DeclaredVar
	 *
	 * Constraint:
	 *     varName=[VarName|ID]
	 */
	protected void sequence_DeclaredVar(ISerializationContext context, DeclaredVar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.DECLARED_VAR__VAR_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.DECLARED_VAR__VAR_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclaredVarAccess().getVarNameVarNameIDTerminalRuleCall_0_1(), semanticObject.getVarName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EqualityOperator returns Operator
	 *
	 * Constraint:
	 *     (op='<' | op='>' | op='<=' | op='>=')
	 */
	protected void sequence_EqualityOperator(ISerializationContext context, Operator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCommand returns FloatLiteral
	 *     Expression returns FloatLiteral
	 *     Assignment returns FloatLiteral
	 *     Assignment.BinaryOperation_1_0_0_0 returns FloatLiteral
	 *     OrExpression returns FloatLiteral
	 *     OrExpression.BinaryOperation_1_0_0_0 returns FloatLiteral
	 *     XorExpression returns FloatLiteral
	 *     XorExpression.BinaryOperation_1_0_0_0 returns FloatLiteral
	 *     AndExpression returns FloatLiteral
	 *     AndExpression.BinaryOperation_1_0_0_0 returns FloatLiteral
	 *     Comparison returns FloatLiteral
	 *     Comparison.BinaryOperation_1_0_0_0 returns FloatLiteral
	 *     EquExpression returns FloatLiteral
	 *     EquExpression.BinaryOperation_1_0_0_0 returns FloatLiteral
	 *     AddExpression returns FloatLiteral
	 *     AddExpression.BinaryOperation_1_0_0_0 returns FloatLiteral
	 *     MultiplicativeExpression returns FloatLiteral
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns FloatLiteral
	 *     PowerExpression returns FloatLiteral
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns FloatLiteral
	 *     UnaryOperation returns FloatLiteral
	 *     PrimaryExpression returns FloatLiteral
	 *     Literal returns FloatLiteral
	 *     NumericLiteral returns FloatLiteral
	 *     FloatLiteral returns FloatLiteral
	 *
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_FloatLiteral(ISerializationContext context, FloatLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.FLOAT_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.FLOAT_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFloatLiteralAccess().getValueFLOATTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCommand returns ForStatement
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (operatorExpr=DeclaredVar startExpr=Expression endExpr=Expression stepExpe=Expression? commands+=AbstractCommand+)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCommand returns FunctionCall
	 *     Expression returns FunctionCall
	 *     Assignment returns FunctionCall
	 *     Assignment.BinaryOperation_1_0_0_0 returns FunctionCall
	 *     OrExpression returns FunctionCall
	 *     OrExpression.BinaryOperation_1_0_0_0 returns FunctionCall
	 *     XorExpression returns FunctionCall
	 *     XorExpression.BinaryOperation_1_0_0_0 returns FunctionCall
	 *     AndExpression returns FunctionCall
	 *     AndExpression.BinaryOperation_1_0_0_0 returns FunctionCall
	 *     Comparison returns FunctionCall
	 *     Comparison.BinaryOperation_1_0_0_0 returns FunctionCall
	 *     EquExpression returns FunctionCall
	 *     EquExpression.BinaryOperation_1_0_0_0 returns FunctionCall
	 *     AddExpression returns FunctionCall
	 *     AddExpression.BinaryOperation_1_0_0_0 returns FunctionCall
	 *     MultiplicativeExpression returns FunctionCall
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns FunctionCall
	 *     PowerExpression returns FunctionCall
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns FunctionCall
	 *     UnaryOperation returns FunctionCall
	 *     PrimaryExpression returns FunctionCall
	 *     FunctionCall returns FunctionCall
	 *
	 * Constraint:
	 *     (fbName=[FunctionName|ID] param=SubprogramParam)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.FUNCTION_CALL__FB_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.FUNCTION_CALL__FB_NAME));
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.EXPRESSION__PARAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.EXPRESSION__PARAM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getFbNameFunctionNameIDTerminalRuleCall_1_0_1(), semanticObject.getFbName());
		feeder.accept(grammarAccess.getFunctionCallAccess().getParamSubprogramParamParserRuleCall_3_0(), semanticObject.getParam());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionName returns FunctionName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_FunctionName(ISerializationContext context, FunctionName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.FUNCTION_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.FUNCTION_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     HeaderBlock returns HeaderBlock
	 *
	 * Constraint:
	 *     algorithmName=STRING
	 */
	protected void sequence_HeaderBlock(ISerializationContext context, HeaderBlock semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.HEADER_BLOCK__ALGORITHM_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.HEADER_BLOCK__ALGORITHM_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHeaderBlockAccess().getAlgorithmNameSTRINGTerminalRuleCall_1_0(), semanticObject.getAlgorithmName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCommand returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (expr=Expression commands+=AbstractCommand+ elseCommands+=AbstractCommand*)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCommand returns IntLiteral
	 *     Expression returns IntLiteral
	 *     Assignment returns IntLiteral
	 *     Assignment.BinaryOperation_1_0_0_0 returns IntLiteral
	 *     OrExpression returns IntLiteral
	 *     OrExpression.BinaryOperation_1_0_0_0 returns IntLiteral
	 *     XorExpression returns IntLiteral
	 *     XorExpression.BinaryOperation_1_0_0_0 returns IntLiteral
	 *     AndExpression returns IntLiteral
	 *     AndExpression.BinaryOperation_1_0_0_0 returns IntLiteral
	 *     Comparison returns IntLiteral
	 *     Comparison.BinaryOperation_1_0_0_0 returns IntLiteral
	 *     EquExpression returns IntLiteral
	 *     EquExpression.BinaryOperation_1_0_0_0 returns IntLiteral
	 *     AddExpression returns IntLiteral
	 *     AddExpression.BinaryOperation_1_0_0_0 returns IntLiteral
	 *     MultiplicativeExpression returns IntLiteral
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns IntLiteral
	 *     PowerExpression returns IntLiteral
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns IntLiteral
	 *     UnaryOperation returns IntLiteral
	 *     PrimaryExpression returns IntLiteral
	 *     Literal returns IntLiteral
	 *     NumericLiteral returns IntLiteral
	 *     IntLiteral returns IntLiteral
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntLiteral(ISerializationContext context, IntLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.INT_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.INT_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntLiteralAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (header=HeaderBlock globalDeclarations=DeclarationsBlock? subprograms=Subprograms? commands=BlockCommand)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultiplicativeOperator returns Operator
	 *
	 * Constraint:
	 *     (op='*' | op='/' | op='MOD' | op='%')
	 */
	protected void sequence_MultiplicativeOperator(ISerializationContext context, Operator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotOperator returns Operator
	 *
	 * Constraint:
	 *     (op='NAO' | op='-')
	 */
	protected void sequence_NotOperator(ISerializationContext context, Operator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OptDecimalPrecision returns OptDecimalPrecision
	 *
	 * Constraint:
	 *     (firstPrecision=INT secondPrecision=INT?)
	 */
	protected void sequence_OptDecimalPrecision(ISerializationContext context, OptDecimalPrecision semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OrOperator returns Operator
	 *
	 * Constraint:
	 *     op='OU'
	 */
	protected void sequence_OrOperator(ISerializationContext context, Operator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.OPERATOR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.OPERATOR__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrOperatorAccess().getOpOUKeyword_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OtherCase returns OtherCase
	 *
	 * Constraint:
	 *     otherCaseCommands+=AbstractCommand+
	 */
	protected void sequence_OtherCase(ISerializationContext context, OtherCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCommand returns PiLiteral
	 *     Expression returns PiLiteral
	 *     Assignment returns PiLiteral
	 *     Assignment.BinaryOperation_1_0_0_0 returns PiLiteral
	 *     OrExpression returns PiLiteral
	 *     OrExpression.BinaryOperation_1_0_0_0 returns PiLiteral
	 *     XorExpression returns PiLiteral
	 *     XorExpression.BinaryOperation_1_0_0_0 returns PiLiteral
	 *     AndExpression returns PiLiteral
	 *     AndExpression.BinaryOperation_1_0_0_0 returns PiLiteral
	 *     Comparison returns PiLiteral
	 *     Comparison.BinaryOperation_1_0_0_0 returns PiLiteral
	 *     EquExpression returns PiLiteral
	 *     EquExpression.BinaryOperation_1_0_0_0 returns PiLiteral
	 *     AddExpression returns PiLiteral
	 *     AddExpression.BinaryOperation_1_0_0_0 returns PiLiteral
	 *     MultiplicativeExpression returns PiLiteral
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns PiLiteral
	 *     PowerExpression returns PiLiteral
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns PiLiteral
	 *     UnaryOperation returns PiLiteral
	 *     PrimaryExpression returns PiLiteral
	 *     Literal returns PiLiteral
	 *     NumericLiteral returns PiLiteral
	 *     PiLiteral returns PiLiteral
	 *
	 * Constraint:
	 *     value='pi'
	 */
	protected void sequence_PiLiteral(ISerializationContext context, PiLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.PI_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.PI_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPiLiteralAccess().getValuePiKeyword_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PowerOperator returns Operator
	 *
	 * Constraint:
	 *     op='^'
	 */
	protected void sequence_PowerOperator(ISerializationContext context, Operator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.OPERATOR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.OPERATOR__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerOperatorAccess().getOpCircumflexAccentKeyword_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCommand returns Expression
	 *     Expression returns Expression
	 *     Assignment returns Expression
	 *     Assignment.BinaryOperation_1_0_0_0 returns Expression
	 *     OrExpression returns Expression
	 *     OrExpression.BinaryOperation_1_0_0_0 returns Expression
	 *     XorExpression returns Expression
	 *     XorExpression.BinaryOperation_1_0_0_0 returns Expression
	 *     AndExpression returns Expression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns Expression
	 *     Comparison returns Expression
	 *     Comparison.BinaryOperation_1_0_0_0 returns Expression
	 *     EquExpression returns Expression
	 *     EquExpression.BinaryOperation_1_0_0_0 returns Expression
	 *     AddExpression returns Expression
	 *     AddExpression.BinaryOperation_1_0_0_0 returns Expression
	 *     MultiplicativeExpression returns Expression
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns Expression
	 *     PowerExpression returns Expression
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns Expression
	 *     UnaryOperation returns Expression
	 *     PrimaryExpression returns Expression
	 *     PreDefinedFunctionCall returns Expression
	 *
	 * Constraint:
	 *     (preDefFunctionName=PredefineFunctions param=SubprogramParam)
	 */
	protected void sequence_PreDefinedFunctionCall(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.EXPRESSION__PRE_DEF_FUNCTION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.EXPRESSION__PRE_DEF_FUNCTION_NAME));
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.EXPRESSION__PARAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.EXPRESSION__PARAM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreDefinedFunctionCallAccess().getPreDefFunctionNamePredefineFunctionsParserRuleCall_0_0(), semanticObject.getPreDefFunctionName());
		feeder.accept(grammarAccess.getPreDefinedFunctionCallAccess().getParamSubprogramParamParserRuleCall_2_0(), semanticObject.getParam());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProcedureCall returns ProcedureCall
	 *
	 * Constraint:
	 *     (fbName=[ProcedureName|ID] param=SubprogramParam)
	 */
	protected void sequence_ProcedureCall(ISerializationContext context, ProcedureCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.PROCEDURE_CALL__FB_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.PROCEDURE_CALL__FB_NAME));
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.EXPRESSION__PARAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.EXPRESSION__PARAM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcedureCallAccess().getFbNameProcedureNameIDTerminalRuleCall_1_0_1(), semanticObject.getFbName());
		feeder.accept(grammarAccess.getProcedureCallAccess().getParamSubprogramParamParserRuleCall_3_0(), semanticObject.getParam());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProcedureName returns ProcedureName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ProcedureName(ISerializationContext context, ProcedureName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.PROCEDURE_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.PROCEDURE_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcedureNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCommand returns ReadCommand
	 *     ReadCommand returns ReadCommand
	 *
	 * Constraint:
	 *     paramList=DeclaredVarList
	 */
	protected void sequence_ReadCommand(ISerializationContext context, ReadCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.READ_COMMAND__PARAM_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.READ_COMMAND__PARAM_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReadCommandAccess().getParamListDeclaredVarListParserRuleCall_2_0(), semanticObject.getParamList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCommand returns RepeatStatement
	 *     RepeatStatement returns RepeatStatement
	 *
	 * Constraint:
	 *     (commands+=AbstractCommand+ untilExpr=Expression)
	 */
	protected void sequence_RepeatStatement(ISerializationContext context, RepeatStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCommand returns ReturnStatement
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.RETURN_STATEMENT__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.RETURN_STATEMENT__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnStatementAccess().getExprExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCommand returns StringLiteral
	 *     Expression returns StringLiteral
	 *     Assignment returns StringLiteral
	 *     Assignment.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     OrExpression returns StringLiteral
	 *     OrExpression.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     XorExpression returns StringLiteral
	 *     XorExpression.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     AndExpression returns StringLiteral
	 *     AndExpression.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     Comparison returns StringLiteral
	 *     Comparison.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     EquExpression returns StringLiteral
	 *     EquExpression.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     AddExpression returns StringLiteral
	 *     AddExpression.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     MultiplicativeExpression returns StringLiteral
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     PowerExpression returns StringLiteral
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     UnaryOperation returns StringLiteral
	 *     PrimaryExpression returns StringLiteral
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SubprogramParamDeclaration returns SubprogramParamDeclaration
	 *
	 * Constraint:
	 *     (paramList+=Variable paramList+=Variable*)
	 */
	protected void sequence_SubprogramParamDeclaration(ISerializationContext context, SubprogramParamDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SubprogramParam returns SubprogramParam
	 *
	 * Constraint:
	 *     (expression+=Expression expression+=Expression*)
	 */
	protected void sequence_SubprogramParam(ISerializationContext context, SubprogramParam semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Subprograms returns Subprograms
	 *
	 * Constraint:
	 *     blockSubPrograms+=BlockSubPrograms+
	 */
	protected void sequence_Subprograms(ISerializationContext context, Subprograms semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCommand returns SwitchCaseStatement
	 *     SwitchCaseStatement returns SwitchCaseStatement
	 *
	 * Constraint:
	 *     (variable=[VarName|ID] caseList+=CaseList+ otherCase=OtherCase?)
	 */
	protected void sequence_SwitchCaseStatement(ISerializationContext context, SwitchCaseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCommand returns UnaryOperation
	 *     Expression returns UnaryOperation
	 *     Assignment returns UnaryOperation
	 *     Assignment.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     OrExpression returns UnaryOperation
	 *     OrExpression.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     XorExpression returns UnaryOperation
	 *     XorExpression.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     AndExpression returns UnaryOperation
	 *     AndExpression.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     Comparison returns UnaryOperation
	 *     Comparison.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     EquExpression returns UnaryOperation
	 *     EquExpression.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     AddExpression returns UnaryOperation
	 *     AddExpression.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     MultiplicativeExpression returns UnaryOperation
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     PowerExpression returns UnaryOperation
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     UnaryOperation returns UnaryOperation
	 *     PrimaryExpression returns UnaryOperation
	 *
	 * Constraint:
	 *     (op=NotOperator operand=UnaryOperation)
	 */
	protected void sequence_UnaryOperation(ISerializationContext context, UnaryOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.UNARY_OPERATION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.UNARY_OPERATION__OP));
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.UNARY_OPERATION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.UNARY_OPERATION__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryOperationAccess().getOpNotOperatorParserRuleCall_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getUnaryOperationAccess().getOperandUnaryOperationParserRuleCall_0_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclaration returns VarDeclaration
	 *
	 * Constraint:
	 *     (vars+=VarName vars+=VarName*)
	 */
	protected void sequence_VarDeclaration(ISerializationContext context, VarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarName returns VarName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_VarName(ISerializationContext context, VarName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.VAR_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.VAR_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarType returns VarType
	 *
	 * Constraint:
	 *     (typeName='real' | typeName='inteiro' | typeName='caractere' | typeName='caracter' | typeName='logico')
	 */
	protected void sequence_VarType(ISerializationContext context, VarType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (varDeclaration=VarDeclaration type=VarType)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.VARIABLE__VAR_DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.VARIABLE__VAR_DECLARATION));
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.VARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.VARIABLE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getVarDeclarationVarDeclarationParserRuleCall_0_0(), semanticObject.getVarDeclaration());
		feeder.accept(grammarAccess.getVariableAccess().getTypeVarTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCommand returns WhileStatement
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (whileExpr=Expression commands+=AbstractCommand+)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractCommand returns WriteCommand
	 *     WriteCommand returns WriteCommand
	 *
	 * Constraint:
	 *     ((writeCommand='escreva' | writeCommand='escreval') writeParam=WriteParam)
	 */
	protected void sequence_WriteCommand(ISerializationContext context, WriteCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WriteParam returns WriteParam
	 *
	 * Constraint:
	 *     (params=SubprogramParam precision=OptDecimalPrecision?)
	 */
	protected void sequence_WriteParam(ISerializationContext context, WriteParam semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XorOperator returns Operator
	 *
	 * Constraint:
	 *     op='XOU'
	 */
	protected void sequence_XorOperator(ISerializationContext context, Operator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PortugolPackage.Literals.OPERATOR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PortugolPackage.Literals.OPERATOR__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXorOperatorAccess().getOpXOUKeyword_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
}

/*
 * generated by Xtext 2.9.0
 */
package org.hopper.language.generator

import java.text.Normalizer
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.hopper.language.portugol.AbstractCommand
import org.hopper.language.portugol.BinaryOperation
import org.hopper.language.portugol.BlockCommand
import org.hopper.language.portugol.BlockFunction
import org.hopper.language.portugol.BlockProcedure
import org.hopper.language.portugol.BlockSubPrograms
import org.hopper.language.portugol.BooleanLiteral
import org.hopper.language.portugol.BreakStatement
import org.hopper.language.portugol.CaseList
import org.hopper.language.portugol.DeclarationsBlock
import org.hopper.language.portugol.DeclaredVar
import org.hopper.language.portugol.Expression
import org.hopper.language.portugol.FloatLiteral
import org.hopper.language.portugol.ForStatement
import org.hopper.language.portugol.FunctionCall
import org.hopper.language.portugol.HeaderBlock
import org.hopper.language.portugol.IfStatement
import org.hopper.language.portugol.IntLiteral
import org.hopper.language.portugol.Model
import org.hopper.language.portugol.Operator
import org.hopper.language.portugol.OtherCase
import org.hopper.language.portugol.PiLiteral
import org.hopper.language.portugol.ReadCommand
import org.hopper.language.portugol.RepeatStatement
import org.hopper.language.portugol.ReturnStatement
import org.hopper.language.portugol.StringLiteral
import org.hopper.language.portugol.SubprogramParam
import org.hopper.language.portugol.Subprograms
import org.hopper.language.portugol.SwitchCaseStatement
import org.hopper.language.portugol.UnaryOperation
import org.hopper.language.portugol.VarName
import org.hopper.language.portugol.VarType
import org.hopper.language.portugol.Variable
import org.hopper.language.portugol.WhileStatement
import org.hopper.language.portugol.WriteCommand
import org.hopper.language.portugol.WriteParam
import static extension org.eclipse.xtext.EcoreUtil2.*

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class PortugolGenerator extends AbstractGenerator {

	private String className;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (e : resource.allContents.toIterable.filter(typeof(Model))) {
			generateClassName(e);
			fsa.generateFile("generated/" + className + ".java", e.compile);
		}
	}

	def generateClassName(Model e) {
		className = Normalizer.normalize(e.header.algorithmName.trim, Normalizer.Form.NFD);
		className = className.replaceAll("_", " ")

		var sbClassName = new StringBuilder(className);

		var spaceIndex = 0;
		while ((spaceIndex = sbClassName.indexOf(' ', spaceIndex)) > -1) {
			var upperLetter = Character.toUpperCase(sbClassName.charAt(spaceIndex + 1));
			sbClassName.setCharAt(spaceIndex + 1, upperLetter);
			spaceIndex++;
		}
		className = sbClassName.toString();
		className = className.replaceAll("[^\\p{ASCII}]", "");
		className = className.replaceAll(" ", "")
		className = className.toFirstUpper;
	}

	def compile(Model model) {
		'''
			package hopper;
			
			import java.lang.*;
			import java.io.BufferedReader;
			import java.io.IOException;
			import java.io.InputStreamReader;
					
			public class «model.header.compile»{
				«IF model.globalDeclarations != null»
					«model.globalDeclarations.compile(true)»
				«ENDIF»	
				
				«IF model.subprograms != null»
					«model.subprograms.compile»
				«ENDIF»					
				«model.commands.compile»
			}	
		'''
	}

	def compile(HeaderBlock header) {
		'''«className»'''
	}

	def compile(BlockCommand blockCommand) {
		'''
			public static void main(String[] args) throws IOException {
				«IF blockCommand.commands!=null»
					«blockCommand.commands.compile»
				«ENDIF»
			}
		'''
	}

	def compile(EList<AbstractCommand> commands) {
		''' 
			«IF commands != null»
				«FOR command : commands»
					«command.compile»
				«ENDFOR»
			«ENDIF»
		'''
	}

	def compile(AbstractCommand command) {
		switch (command) {
			ReadCommand: '''«command.compile»'''
			WriteCommand: '''«command.compile»'''
			Expression: '''«command.compile»;'''
			IfStatement: '''«command.compile»'''
			SwitchCaseStatement: '''«command.compile»'''
			ForStatement: '''«command.compile»'''
			RepeatStatement: '''«command.compile»'''
			WhileStatement: '''«command.compile»'''
			BreakStatement: '''break;'''
			ReturnStatement: '''return;'''
		}
	}

	def compile(ReadCommand readCommand) {
		var compiledStatement = new StringBuilder()
		if (readCommand != null && readCommand.paramList != null && readCommand.paramList.vars != null) {

			compiledStatement.append('''
				BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
				String ___inputRead;	
							
			''')

			for (currentVar : readCommand.paramList.vars) {

				compiledStatement.append('''
					___inputRead = br.readLine();
				''')

				var parentProcedure = currentVar.getContainerOfType(BlockProcedure)

				if (parentProcedure != null) {
					compileVarReadStatement(parentProcedure.declarations, currentVar, compiledStatement)
				} else {
					var parentFunction = currentVar.getContainerOfType(BlockFunction)
					if (parentFunction != null) {
						compileVarReadStatement(parentFunction.declarations, currentVar, compiledStatement)
					} else {
						var parentModel = currentVar.getContainerOfType(Model)
						if (parentModel != null) {
							compileVarReadStatement(parentModel.globalDeclarations, currentVar, compiledStatement)
						}
					}
				}
			}
		}

		return compiledStatement.toString
	}

	def compileVarReadStatement(DeclarationsBlock declarations, VarName currentVar, StringBuilder compiledStatement) {
		if (declarations != null && declarations.vars != null) {
			var varLists = declarations.vars
			for (varItem : varLists) {
				if (varItem.varDeclaration != null && varItem.varDeclaration.vars != null) {
					var varNames = varItem.varDeclaration.vars;
					val varType = varItem.type
					var castType = ""

					switch (varType.typeName.toUpperCase) {
						case 'REAL': castType = 'Float.parseFloat('
						case 'INTEIRO': castType = 'Integer.parseInt('
						case 'LOGICO': castType = 'Boolean.parseBoolean('
					}

					for (varName : varNames) {
						if (currentVar.name.equalsIgnoreCase(varName.name)) {
							compiledStatement.append(
								'''try{«varName.name» = «castType»___inputRead«IF !castType.isNullOrEmpty»)«ENDIF»;}catch(NumberFormatException nfe){System.err.println("Invalid Format!");}'''
							)
						}
					}
				}
			}
		}
	}

	def compile(
		WriteCommand command) {
		'''System.out.print«IF command.writeCommand.equalsIgnoreCase('escreval')»ln«ENDIF»(«command.writeParam.compile»);'''
	}

	def compile(WhileStatement whileStmt) {
		'''
			while(«whileStmt.whileExpr.compile»){
				«whileStmt.commands.compile»
			}
		'''
	}

	def compile(RepeatStatement rptStmt) {
		'''
			do{
				«rptStmt.commands.compile»
			}while(«rptStmt.untilExpr.compile»);
		'''
	}

	def compile(
		ForStatement forStmt) {
		'''
			«forStmt.operatorExpr.compile» = «forStmt.startExpr.compile»;
			while(«forStmt.operatorExpr.compile» != «forStmt.endExpr.compile»){								
				«forStmt.commands.compile»
				«IF forStmt.stepExpe != null»«forStmt.operatorExpr.compile» = «forStmt.stepExpe.compile»;«ELSE»«forStmt.operatorExpr.compile»++;«ENDIF»
			}
		'''
	}

	def compile(SwitchCaseStatement swcaseStmt) {
		'''
			switch(«swcaseStmt.variable.name»){
				«FOR caseStmt : swcaseStmt.caseList»
					«caseStmt.compile»
				«ENDFOR»
				«IF swcaseStmt.otherCase!=null»
					«swcaseStmt.otherCase.compile»
				«ENDIF»
			}
		'''
	}

	def compile(CaseList caseStmt) {
		'''
			case «caseStmt.expr.compile»:
				«caseStmt.commands.compile»			
		'''
	}

	def compile(OtherCase caseStmt) {
		'''
			default:
				«caseStmt.otherCaseCommands.compile»			
		'''
	}

	def compile(IfStatement ifstmt) {
		'''
			if(«ifstmt.expr.compile»){
				«ifstmt.commands.compile»
			}«IF ifstmt.elseCommands !=null»else{
					«ifstmt.elseCommands.compile»
			}«ENDIF»
		'''
	}

	def compile(
		WriteParam writeParam) {
		'''«IF writeParam.params != null && writeParam.params.expression != null»«FOR expression : writeParam.params.expression»«IF writeParam.params.expression.indexOf(expression)>0»+«ENDIF»«expression.compile»«ENDFOR»«ENDIF»'''
	}

	def compile(Expression e) {
		switch (e) {
			BinaryOperation: '''«e.compile»'''
			UnaryOperation: '''«e.compile»'''
			StringLiteral: '''"«e.value»"'''
			IntLiteral: '''«e.value»'''
			FloatLiteral: '''«e.value»'''
			PiLiteral: '''Math.PI'''
			BooleanLiteral: '''«e.compile»'''
			DeclaredVar: '''«e.varName.name»'''
			FunctionCall: '''«e.fbName.name»(«e.param.compile»)'''
		}.toString
	}

	def compile(
		BinaryOperation e) {
		'''«IF !e.op.op.equalsIgnoreCase('^')»«e.left.compile» «e.op.compile» «e.right.compile»«ELSE»Math.pow(«e.left.compile», «e.right.compile»)«ENDIF»'''
	}

	def compile(UnaryOperation e) {
		'''«e.op.compile» «e.operand.compile»'''
	}

	def compile(BooleanLiteral boolit) {
		'''«IF boolit.value.equalsIgnoreCase('verdadeiro')»true«ELSE»false«ENDIF»'''
	}

	def compile(
		SubprogramParam params) {
		'''«IF params!=null && params.expression!=null»«FOR expression : params.expression»«IF params.expression.indexOf(expression) > 0», «ENDIF»«expression.compile»«ENDFOR»«ENDIF»'''
	}

	def compile(Operator op) {
		switch (op.op.toUpperCase) {
			case '<-': '''='''
			case ('OU'): '''||'''
			case ('XOU'): '''^'''
			case ('E'): '''&&'''
			case ('='): '''=='''
			case ('<>'): '''!='''
			case ('MOD'): '''%'''
			case ('NAO'): '''!'''
			default:
				op.op
		}
	}

	def compile(Subprograms subprograms) {
		''' 
			«IF subprograms != null && subprograms.blockSubPrograms != null»
				«FOR subprogram : subprograms.blockSubPrograms»
					«subprogram.compile»
				«ENDFOR»
			«ENDIF»
		'''
	}

	def compile(
		BlockSubPrograms subprogram) {
		switch (subprogram) {
			BlockFunction: '''
				private static «subprogram.returnType.compile» «subprogram.functionName.name»(«IF subprogram.params!=null»«subprogram.params.paramList.compileAsParameter»«ENDIF»){
					«IF subprogram.declarations != null»
						«subprogram.declarations.compile(false)»
						«subprogram.commands.compile»
					«ENDIF»	
				}
			'''
			BlockProcedure: '''
				private static void «subprogram.procedureName.name»(«IF subprogram.params!=null»«subprogram.params.paramList.compileAsParameter»«ENDIF»){
					«IF subprogram.declarations != null»
						«subprogram.declarations.compile(false)»
						«subprogram.commands.compile»
					«ENDIF»	
				}
			'''
		}
	}

	def compile(DeclarationsBlock declBlock, boolean useModifier) {
		'''
			«FOR currVarDecl : declBlock.vars»
				«compile(currVarDecl, useModifier)»
			«ENDFOR»
		'''
	}

	def compileAsParameter(
		EList<Variable> variables) {
		'''«IF variables != null»«FOR variable: variables»«IF variables.indexOf(variable) > 0», «ENDIF»«FOR currVarName : variable.varDeclaration.vars»«IF variable.varDeclaration.vars.indexOf(currVarName) > 0», «ENDIF»«variable.type.compile» «currVarName.name»«ENDFOR»«ENDFOR»«ENDIF»'''
	}

	def compile(Variable variable,
		boolean useModifier) {
		'''«IF useModifier»private static «ENDIF»«variable.type.compile»«FOR currVarName : variable.varDeclaration.vars»«IF variable.varDeclaration.vars.indexOf(currVarName) > 0»,«ENDIF» «currVarName.name»«ENDFOR»;'''
	}

	def compile(
		VarType varType) {
		'''«IF varType.typeName.equalsIgnoreCase('inteiro')»int«ELSEIF varType.typeName.equalsIgnoreCase('real')»float«ELSEIF varType.typeName.equalsIgnoreCase('caracter') || varType.typeName.equalsIgnoreCase('caractere')»String«ENDIF»'''
	}
}

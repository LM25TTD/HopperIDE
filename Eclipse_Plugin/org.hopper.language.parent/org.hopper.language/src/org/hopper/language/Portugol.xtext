grammar org.hopper.language.Portugol with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate portugol "http://www.hopper.org/language/Portugol"

Model:
	header=HeaderBlock
	globalDeclarations=DeclarationsBlock
	(subprograms=Subprograms)?
	commands=BlockCommand;

HeaderBlock:
	'algoritmo' algorithmName=STRING END_COMMAND;

DeclarationsBlock:
	'var'
	(vars+=Variable END_COMMAND)+;

Variable:
	varDeclaration=VarDeclaration ':' type=VarType;

VarDeclaration:
	(vars+=VarName) (',' vars+=VarName)*;

DeclaredVarList:
	(vars+=[VarName]) (',' vars+=[VarName])*;

VarName:
	name=ID;

VarType:
	typeName=('real' | 'inteiro' | 'caractere' | 'caracter');

Subprograms:
	(blockSubPrograms+=BlockSubPrograms)+;

BlockSubPrograms:
	BlockFunction | BlockProcedure;

ProcedureName:
	name=ID;

FunctionName:
	name=ID;

BlockFunction:
	'funcao' functionName=FunctionName '(' paramList=Variable ')' ':' returnType=VarType
	(declarations=DeclarationsBlock)?
	'inicio'
	(commands+=AbstractCommand)+
	'fimfuncao';

BlockProcedure:
	'procedimento' procedure=ProcedureName '(' paramList=Variable ')'
	(declarations=DeclarationsBlock)?
	'inicio'
	(commands+=AbstractCommand)+
	'fimprocedimento';

BlockCommand:
	'inicio'
	(commands+=AbstractCommand)+
	'fimalgoritmo';

AbstractCommand:
	ReadCommand END_COMMAND
	| WriteCommand END_COMMAND
	| Expression END_COMMAND
	| IfStatement
	| SwitchCaseStatement
	| ForStatement
	| RepeatStatement
	| WhileStatement
	| BreakStatement END_COMMAND
	| ReturnStatement END_COMMAND;

BreakStatement:
	{BreakStatement} 'interrompa';

ReturnStatement:
	{ReturnExpression} 'retorne' expr=Expression;

IfStatement:
	'se' expr=Expression 'entao'
	(commands+=AbstractCommand)+
	('senao' (elseCommands+=AbstractCommand)+)?
	'fimse';

SwitchCaseStatement:
	'escolha' variable=[VarName]
	(caseList+=CaseList)+
	(otherCase=OtherCase)?
	'fimescolha';

CaseList:
	'caso' expr=Expression ':'
	(commands+=AbstractCommand)+;

OtherCase:
	'outrocaso' ':'
	(otherCaseCommands+=AbstractCommand)+;

ForStatement:
	'para' operatorExpr=Expression 'de' startExpr=Expression 'ate' endExpr=Expression ('passo' stepExpe=Expression)?
	'faca'
	(commands+=AbstractCommand)+
	'fimpara';

WhileStatement:
	'enquanto' whileExpr=Expression 'faca'
	(commands+=AbstractCommand)+
	'fimenquanto';

RepeatStatement:
	'repita'
	(commands+=AbstractCommand)+
	'ate' (untilExpr=Expression) END_COMMAND;

SubprogramParam:
	expression+=Expression (',' expression+=Expression)*;

ReadCommand:
	'leia' '(' paramList=DeclaredVarList ')';

WriteCommand:
	writeCommand=('escreva' | 'escreval') '(' writeParam=WriteParam ')';

WriteParam:
	params=SubprogramParam (precision=OptDecimalPrecision)?;

OptDecimalPrecision:
	':' firstPrecision=INT (':' secondPrecision=INT)?;

Expression returns Expression:
	Assignment;

Assignment returns Expression:
	OrExpression (=> ({BinaryOperation.left=current} op=('<-')) right=Assignment)*;

OrExpression returns Expression:
	XorExpression (=> ({BinaryOperation.left=current} op=("OU")) right=XorExpression)*;

XorExpression returns Expression:
	AndExpression (=> ({BinaryOperation.left=current} op=("XOU")) right=AndExpression)*;

AndExpression returns Expression:
	Comparison (=> ({BinaryOperation.left=current} op=('&' | 'E')) right=Comparison)*;

Comparison returns Expression:
	EquExpression (=> ({BinaryOperation.left=current} op=('=' | '<>')) right=EquExpression)*;

EquExpression returns Expression:
	AddExpression (=> ({BinaryOperation.left=current} op=('<' | '>' | '<=' | '>=')) right=AddExpression)*;

AddExpression returns Expression:
	MultiplicativeExpression (=> ({BinaryOperation.left=current} op=('+' | '-')) right=MultiplicativeExpression)*;

MultiplicativeExpression returns Expression:
	PowerExpression (=> ({BinaryOperation.left=current} op=('*' | '/' | 'MOD' | '%')) right=PowerExpression)*;

PowerExpression returns Expression:
	UnaryExpression (=> ({BinaryOperation.left=current} op=('^')) right=UnaryExpression)*;

UnaryExpression returns Expression:
	{UnaryExpression} op=('NOT' | '-') operand=UnaryExpression /* right associativity */
	| PrimaryExpression;

PrimaryExpression returns Expression:
	Literal
	| FunctionCall
	| DeclaredVar
	| '(' Expression ')';

FunctionCall returns Expression:
	fbName=[FunctionName] '(' param=SubprogramParam ')';

ProcedureCall returns Expression:
	fbName=[ProcedureName] '(' param=SubprogramParam ')';

Literal returns Expression:
	NumericLiteral | StringExpression;

DeclaredVar:
	varName=[VarName];

NumericLiteral:
	intValue?=INT | floatValue?=FLOAT;

StringExpression:
	literalString=STRING;

terminal FLOAT:
	INT '.' INT;

END_COMMAND:
	';';
grammar org.hopper.language.Portugol with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate portugol "http://www.hopper.org/language/Portugol"

Model:
	header=HeaderBlock
	globalDeclarations=DeclarationsBlock
	(subprograms=Subprograms)?
	commands=BlockCommand;

HeaderBlock:
	'algoritmo' name=STRING END_COMMAND;

DeclarationsBlock:
	'var' END_COMMAND
	(vars+=Variable END_COMMAND)+;

Variable:
	varDeclaration=VarDeclaration ':' type=VarType;

VarDeclaration:
	(vars+=VarName) (',' vars+=VarName)*;

DeclaredVar:
	(vars+=[VarName]) (',' vars+=[VarName])*;

VarName:
	name=ID;

VarType:
	typeName=('real' | 'inteiro' | 'caractere');

Subprograms:
	(blockSubPrograms+=BlockSubPrograms)+;

BlockSubPrograms:
	BlockFunction | BlockProcedure;

FunctionName:
	name=ID;

ProcedureName:
	name=ID;

BlockFunction:
	'funcao' functionName=FunctionName '(' paramList=Variable ')' ':' returnType=VarType END_COMMAND
	(declarations=DeclarationsBlock)?
	'inicio' END_COMMAND
	(commands+=AbstractCommand)+
	'fimfuncao' END_COMMAND;

BlockProcedure:
	'procedimento' procedure=ProcedureName '(' paramList=Variable ')' END_COMMAND
	(declarations=DeclarationsBlock)?
	'inicio' END_COMMAND
	(commands+=AbstractCommand)+
	'fimprocedimento' END_COMMAND;

BlockCommand:
	'inicio' END_COMMAND
	(commands+=AbstractCommand)+
	'fimalgoritmo' END_COMMAND;

AbstractCommand:
	ReadCommand END_COMMAND
	| WriteCommand END_COMMAND
	| Expression END_COMMAND;

ReadCommand:
	'leia' '(' paramList=DeclaredVar ')';

WriteCommand:
	'escreva' '(' writeParam=WriteParam ')';

WriteParam:
	expression+=Expression (',' expression+=Expression)* (precision=OptDecimalPrecision)?;

OptDecimalPrecision:
	':' firstPrecision=INT (':' secondPrecision=INT)?;

Expression returns Expression:
	Assignment;

Assignment returns Expression:
	{Assignment} target=[VarName] '<-' value=Assignment
	| OrExpression (=> ({BinaryOperation.left=current} op=('<-')) right=Assignment)?;

OrExpression returns Expression:
	XorExpression (=> ({BinaryOperation.left=current} op=("OU")) right=XorExpression)*;

XorExpression returns Expression:
	AndExpression (=> ({BinaryOperation.left=current} op=("XOU")) right=AndExpression)*;

AndExpression returns Expression:
	Comparison (=> ({BinaryOperation.left=current} op=('&' | 'E')) right=Comparison)*;

Comparison returns Expression:
	EquExpression (=> ({BinaryOperation.left=current} op=('=' | '<>')) right=EquExpression)*;

EquExpression returns Expression:
	AddExpression (=> ({BinaryOperation.left=current} op=('<' | '>' | '<=' | '>=')) right=AddExpression)*;

AddExpression returns Expression:
	MultiplicativeExpression (=> ({BinaryOperation.left=current} op=('+' | '-')) right=MultiplicativeExpression)*;

MultiplicativeExpression returns Expression:
	PowerExpression (=> ({BinaryOperation.left=current} op=('*' | '/' | 'MOD' | '%')) right=PowerExpression)*;

PowerExpression returns Expression:
	UnaryExpression (=> ({BinaryOperation.left=current} op=('^')) right=UnaryExpression)*;

UnaryExpression returns Expression:
	{UnaryExpression} op=('NOT' | '-') operand=UnaryExpression /* right associativity */
	| MemberCall;

MemberCall returns Expression:
	PrimaryExpression (=> ({Assignment.assignable=current} feature=[VarName] '<-') value=Assignment)*;

PrimaryExpression returns Expression:
	Literal
	| FunctionCall
	| '(' Expression ')';

FunctionCall returns Expression:
	fbName=[FunctionName] '(' param=WriteParam ')';

ProcedureCall returns Expression:
	fbName=[ProcedureName] '(' param=WriteParam ')';

Literal returns Expression:
	NumericLiteral | StringExpression;

NumericLiteral:
	intValue?=INT
	| floatValue?=FLOAT;

StringExpression:
	literalString=STRING;

terminal FLOAT:
	INT '.' INT;

terminal END_COMMAND:
	((' ' | '\t')* ('\r' | '\n')+ (' ' | '\t')*);
grammar org.hopper.language.Portugol with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate portugol "http://www.hopper.org/language/Portugol"

Model:
	header=HeaderBlock
	globalDeclarations=DeclarationsBlock
	(subprograms=Subprograms)?
	commands=BlockCommand;

HeaderBlock:
	'algoritmo' algorithmName=STRING END_COMMAND;

DeclarationsBlock:
	'var' END_COMMAND
	(vars+=Variable END_COMMAND)+;

Variable:
	varDeclaration=VarDeclaration ':' type=VarType;

VarDeclaration:
	(vars+=VarName) (',' vars+=VarName)*;

DeclaredVarList:
	(vars+=[VarName]) (',' vars+=[VarName])*;

VarName:
	name=ID;

VarType:
	typeName=('real' | 'inteiro' | 'caractere' | 'caracter');

Subprograms:
	(blockSubPrograms+=BlockSubPrograms)+;

BlockSubPrograms:
	BlockFunction | BlockProcedure;

ProcedureName:
	name=ID;

FunctionName:
	name=ID;

BlockFunction:
	'funcao' functionName=FunctionName '(' paramList=Variable ')' ':' returnType=VarType END_COMMAND
	(declarations=DeclarationsBlock)?
	'inicio' END_COMMAND
	(commands+=AbstractCommand)+
	'fimfuncao' END_COMMAND;

BlockProcedure:
	'procedimento' procedure=ProcedureName '(' paramList=Variable ')' END_COMMAND
	(declarations=DeclarationsBlock)?
	'inicio' END_COMMAND
	(commands+=AbstractCommand)+
	'fimprocedimento' END_COMMAND;

BlockCommand:
	'inicio' END_COMMAND
	(commands+=AbstractCommand)+
	'fimalgoritmo' END_COMMAND?;

AbstractCommand:
	ReadCommand END_COMMAND
	| WriteCommand END_COMMAND
	| Expression END_COMMAND
	| IfStatement END_COMMAND
	| SwitchCaseStatement END_COMMAND
	| ForStatement END_COMMAND
	| RepeatStatement END_COMMAND
	| WhileStatement END_COMMAND;

IfStatement:
	'se' expr=Expression 'entao' END_COMMAND
	(commands+=AbstractCommand)+
	('senao' END_COMMAND (elseCommands+=AbstractCommand)+)?
	'fimse';

SwitchCaseStatement:
	'escolha' variable=[VarName] END_COMMAND
	(caseList+=CaseList)+
	(otherCase=OtherCase)?
	'fimescolha';

CaseList:
	'caso' expr=Expression END_COMMAND
	(commands+=AbstractCommand)+
	(breakStatement?='interrompa' END_COMMAND)?;

OtherCase:
	'outrocaso' END_COMMAND
	(otherCaseCommands+=AbstractCommand)+
	(breakStatement?='interrompa' END_COMMAND)?;

ForStatement:
	'para' operatorExpr=Expression 'de' startExpr=Expression 'ate' endExpr=Expression ('passo' stepExpe=Expression)?
	'faca' END_COMMAND
	(commands+=AbstractCommand)+
	'fimpara';

WhileStatement:
	'enquanto' whileExpr=Expression 'faca' END_COMMAND
	(commands+=AbstractCommand)+
	'fimenquanto';

RepeatStatement:
	'repita' END_COMMAND
	(commands+=AbstractCommand)+
	'ate' (untilExpr=Expression);

SubprogramParam:
	expression+=Expression (',' expression+=Expression)*;

ReadCommand:
	'leia' '(' paramList=DeclaredVarList ')';

WriteCommand:
	writeCommand=('escreva' | 'escreval') '(' writeParam=WriteParam ')';

WriteParam:
	params=SubprogramParam (precision=OptDecimalPrecision)?;

OptDecimalPrecision:
	':' firstPrecision=INT (':' secondPrecision=INT)?;

Expression returns Expression:
	Assignment;

Assignment returns Expression:
	OrExpression (=> ({BinaryOperation.left=current} op=('<-')) right=Assignment)*;

OrExpression returns Expression:
	XorExpression (=> ({BinaryOperation.left=current} op=("OU")) right=XorExpression)*;

XorExpression returns Expression:
	AndExpression (=> ({BinaryOperation.left=current} op=("XOU")) right=AndExpression)*;

AndExpression returns Expression:
	Comparison (=> ({BinaryOperation.left=current} op=('&' | 'E')) right=Comparison)*;

Comparison returns Expression:
	EquExpression (=> ({BinaryOperation.left=current} op=('=' | '<>')) right=EquExpression)*;

EquExpression returns Expression:
	AddExpression (=> ({BinaryOperation.left=current} op=('<' | '>' | '<=' | '>=')) right=AddExpression)*;

AddExpression returns Expression:
	MultiplicativeExpression (=> ({BinaryOperation.left=current} op=('+' | '-')) right=MultiplicativeExpression)*;

MultiplicativeExpression returns Expression:
	PowerExpression (=> ({BinaryOperation.left=current} op=('*' | '/' | 'MOD' | '%')) right=PowerExpression)*;

PowerExpression returns Expression:
	UnaryExpression (=> ({BinaryOperation.left=current} op=('^')) right=UnaryExpression)*;

UnaryExpression returns Expression:
	{UnaryExpression} op=('NOT' | '-') operand=UnaryExpression /* right associativity */
	| PrimaryExpression;

PrimaryExpression returns Expression:
	Literal | FunctionCall | DeclaredVar | '(' Expression ')';

FunctionCall returns Expression:
	fbName=[FunctionName] '(' param=SubprogramParam ')';

ProcedureCall returns Expression:
	fbName=[ProcedureName] '(' param=SubprogramParam ')';

Literal returns Expression:
	NumericLiteral | StringExpression;

DeclaredVar:
	varName=[VarName];

NumericLiteral:
	intValue?=INT | floatValue?=FLOAT;

StringExpression:
	literalString=STRING;

terminal FLOAT:
	INT '.' INT;

terminal END_COMMAND:
	((' ' | '\t')* ('\r' | '\n')+ (' ' | '\t')*);